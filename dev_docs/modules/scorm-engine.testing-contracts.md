# SCORM Engine Testing Contracts

This addendum defines module-scoped testing contracts and matrices for the SCORM Engine across CAM, RTE, and SN, aligning with the refreshed strategy in [guides/testing-strategy.md](../guides/testing-strategy.md:1) and the harness rules in [architecture/testing-architecture.md](../architecture/testing-architecture.md:1). Use these contracts to author unit, contract, integration, scenario, and perf tests without deep-imports.

Purpose
- Make boundaries and invariants explicit.
- Ensure consistent, deterministic tests.
- Provide coverage matrices to meet thresholds:
  - Global: Lines ≥ 80%, Branches ≥ 75%
  - RTE/SN: Lines ≥ 85%, Branches ≥ 80%
  - CAM: Lines ≥ 80%, Branches ≥ 75%

Public Entry Points
- CAM: [src/main/services/scorm/cam/index.js](../../src/main/services/scorm/cam/index.js:1)
- RTE: [src/main/services/scorm/rte/api-handler.js](../../src/main/services/scorm/rte/api-handler.js:1)
- SN:  [src/main/services/scorm/sn/index.js](../../src/main/services/scorm/sn/index.js:1)
- Shared: [src/shared/constants/error-codes.js](../../src/shared/constants/error-codes.js:1), [src/shared/constants/data-model-schema.js](../../src/shared/constants/data-model-schema.js:1)

Contract A: RTE ApiHandler ↔ DataModel
Surface
- ApiHandler public methods: Initialize, Terminate, GetValue, SetValue, Commit, GetLastError, GetErrorString, GetDiagnostic
- Data model semantics and validation via shared schema

Invariants
1) Lifecycle
- Initial state: not_initialized
- After Initialize(''): running
- After Terminate(''): terminated
- All API calls outside allowed windows return "false" and set correct error code

2) Error Codes
- Validate against [error-codes.js](../../src/shared/constants/error-codes.js:1)
- GetLastError returns last code as a string
- GetErrorString/GetDiagnostic return stable messages for given codes

3) Data Model Semantics
- Type, range, and read-only/write-only rules enforced per [data-model-schema.js](../../src/shared/constants/data-model-schema.js:1)
- Collections: interactions/objectives index rules and _count management
- Time: cmi.session_time accepts valid ISO8601 durations only

4) Commit/Serialization
- Commit serialized with Terminate; no overlapping writes
- Bursty SetValue throttling for cmi.session_time (≥3s)

Test Matrix (Contract/Integration)
- Initialize/Terminate happy path with error-free codes
- Double Initialize/Double Terminate errors
- GetValue/SetValue valid/invalid elements, read-only/write-only violations
- Commit with pending changes; ensure serialized order and success
- cmi.session_time throttling under fake timers
- Error code propagation and message/diagnostic lookups

Performance (Perf)
- p95 ≤ 1.0ms for each API function under baseline harness; warn-only if exceeded

Contract B: CAM ManifestParser ↔ ContentValidator
Surface
- parseManifest(file|xml), validatePackage/validateManifest, analyze (read-only insights separate from compliance)

Invariants
1) Deterministic Parse
- Same input XML yields identical manifest object
- Organizations/resources and identifiers preserved

2) Validation Classes
- Errors vs warnings: consistent classification for missing required vs optional elements
- File integrity: all resource hrefs validated relative to base path

3) UI Outline Contract
- analysis.uiOutline generated by CAM
- Renderer must consume as-is; renderer cannot reconstruct outline

Fixtures
- manifests/: minimal, typical, complex, invalid-structure, missing-files
- packages/: small/medium with known counts

Test Matrix (Unit/Contract/Integration)
- Valid manifest parse (organizations-first)
- Resources fallback outline when orgs absent/invalid
- Integrity: missing file becomes validation error
- Metadata extraction present/absent
- Analysis metrics populated (counts, defaults)

Performance (Perf)
- Small/medium/large package timings logged with warnings only

Contract C: SN SequencingEngine ↔ NavigationHandler
Surface
- SequencingEngine.processNavigationRequest, evaluateSequencingRules
- NavigationHandler.processNavigationRequest, getAvailableNavigation

Invariants
1) Deterministic Requests
- Given fixed tree and clock, requests yield the same target/valid set

2) Control Modes
- Respect choice, flow, forwardOnly, visibility

3) Rules and Limits
- Pre/post-condition rules applied correctly
- Limit conditions for attempts/time enforced

4) Rollup Consistency
- Completion/satisfaction propagate per rollup rules

Fixtures
- activity-trees/: linear, branching choice, forward-only, remediation, global objectives

Test Matrix (Unit/Contract/Integration)
- start/continue/previous/choice scenarios with expected outcomes
- Hidden/disabled/skip actions honored
- Attempt limit and time-limit actions
- Rollup of measure and completion with weights

Performance (Perf)
- Rule evaluation p95 targets defined per scenario with warn-only deltas

Renderer Integration Contracts (Non-E2E)
Scope
- Assert enablement, intent-only UI, logging policy, rate-limiting

Invariants
- No console.* in renderer; logs through [renderer-logger.js](../../src/renderer/utils/renderer-logger.js:1) to app log
- One INFO per channel when rate-limit engages; no additional INFOs
- Renderer consumes analysis.uiOutline directly

Test Matrix (Integration)
- Initialization error handling with centralized notification and app log assertion
- Course load wiring: outline from CAM visible; no reconstruction
- Navigation enablement via UIState normalized flags
- Shutdown: best-effort termination, no ERROR logs for benign cases

Anti-Flake and Determinism Rules
- Fake timers only; no real wall-clock sleeps
- Seeded randomness in tests/setup.js
- Temp FS for integration; cleanup on teardown
- runInBand or maxWorkers tuning for suites with global state

Coverage Guidance
- Unit tests: drive majority of branch coverage
- Contract tests: cover invariants and edge cases at boundaries
- Integration/scenario: focus on cross-module flows, not exhaustive branches
- Renderer integration: prioritize policy assertions (logging, enablement, rate-limiting)

Acceptance Criteria
- RTE/SN reach 85/80, CAM 80/75 coverage with this matrix
- Contract tests replace deep-import unit tests that poked internals
- Perf trend artifacts emitted; warnings only
- Fixtures catalog populated and reused across layers

References
- Strategy: [../guides/testing-strategy.md](../guides/testing-strategy.md:1)
- Harness: [../architecture/testing-architecture.md](../architecture/testing-architecture.md:1)
- Data Model: [../../src/shared/constants/data-model-schema.js](../../src/shared/constants/data-model-schema.js:1)
- Error Codes: [../../src/shared/constants/error-codes.js](../../src/shared/constants/error-codes.js:1)