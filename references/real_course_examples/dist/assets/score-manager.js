import{f as i,h as n,j as o}from"./main.js";class l{constructor(){this.isInitialized=!1,this.config=null,this.cachedScores={}}initialize(t){if(this.isInitialized)throw new Error("[ScoreManager] Already initialized. Do not call initialize() more than once.");if(!t||t.type===null||t.type==="none"){console.log("[ScoreManager] Course scoring disabled. cmi.score.raw will not be set.");return}this._validateConfig(t),this.config=t,this._subscribeToEvents(),this._loadExistingScores(),this.isInitialized=!0,console.log("[ScoreManager] Initialized with scoring type:",t.type)}_validateConfig(t){if(!t.type)throw new Error('[ScoreManager] Configuration must include "type" field');const e=["average","weighted","minimum","maximum","custom"];if(!e.includes(t.type))throw new Error(`[ScoreManager] Invalid scoring type "${t.type}". Must be one of: ${e.join(", ")}`);if(!t.sources||!Array.isArray(t.sources)||t.sources.length===0)throw new Error('[ScoreManager] Configuration must include non-empty "sources" array');if(t.type==="weighted"){if(t.sources.some(s=>typeof s!="object"||!s.id||typeof s.weight!="number"))throw new Error("[ScoreManager] Weighted scoring requires sources with {id, weight} format");const a=t.sources.reduce((s,c)=>s+c.weight,0);if(Math.abs(a-1)>.001)throw new Error(`[ScoreManager] Weights sum to ${a}, not 1.0. Weights must sum exactly to 1.0. Current weights: ${JSON.stringify(t.sources.map(s=>({id:s.id,weight:s.weight})))}`)}if(t.type==="custom"&&typeof t.calculate!="function")throw new Error('[ScoreManager] Custom scoring type requires "calculate" function')}_subscribeToEvents(){i.on("assessment:submitted",t=>{const{assessmentId:e,results:r}=t;r&&typeof r.scorePercentage=="number"&&this._updateSourceScore(`assessment:${e}`,r.scorePercentage)}),i.on("objective:score:updated",t=>{const{objectiveId:e,score:r}=t;typeof r=="number"&&this._updateSourceScore(`objective:${e}`,r)})}_loadExistingScores(){if(!this.config)return;this.config.sources.map(e=>typeof e=="string"?e:e.id).forEach(e=>{const[r,a]=e.split(":");if(r==="objective")try{const s=n.getObjective(a);s&&typeof s.score=="number"&&(this.cachedScores[e]=s.score)}catch{}else if(r==="assessment")try{const s=`assessment_${a}`,c=o.getValue(s,"summary");c&&c.lastResults&&typeof c.lastResults.scorePercentage=="number"&&(this.cachedScores[e]=c.lastResults.scorePercentage)}catch{}}),console.log("[ScoreManager] Loaded existing scores:",this.cachedScores)}_updateSourceScore(t,e){if(!this.isInitialized||!this.config.sources.map(s=>typeof s=="string"?s:s.id).includes(t))return;const a=this.cachedScores[t];this.cachedScores[t]=e,console.log(`[ScoreManager] Score updated: ${t} = ${e} (was ${a||"none"})`),this._calculateAndReportScore()}_calculateAndReportScore(){if(!this.isInitialized||!this.config)return;const t=this._calculateScore();if(t===null){console.log("[ScoreManager] Insufficient data to calculate course score");return}if(t<0||t>100)throw new Error(`[ScoreManager] Calculated score ${t} is out of range [0-100]. This indicates a bug in the scoring calculation.`);try{const e=Math.round(t*100)/100,r=e/100;o.setValue("cmi.score.raw",String(e)),o.setValue("cmi.score.scaled",String(r)),o.setValue("cmi.score.min","0"),o.setValue("cmi.score.max","100"),console.log(`[ScoreManager] Course score updated: ${e}% (scaled: ${r})`),i.emit("course:score:updated",{raw:e,scaled:r,sources:{...this.cachedScores}})}catch(e){const r=`[ScoreManager] Failed to report score to SCORM: ${e.message}`;throw i.emit("score:error",{domain:"score",operation:"reportScore",message:r,context:{calculatedScore:t,error:e}}),e}}_calculateScore(){const{type:t,sources:e}=this.config,r={},a=e.map(c=>typeof c=="string"?c:c.id);a.forEach(c=>{this.cachedScores[c]!==void 0&&(r[c]=this.cachedScores[c])});const s=Object.keys(r).length;if(a.length,s===0)return null;switch(t){case"average":return this._calculateAverage(r);case"weighted":return this._calculateWeighted(r,e);case"minimum":return this._calculateMinimum(r);case"maximum":return this._calculateMaximum(r);case"custom":return this._calculateCustom(r);default:throw new Error(`[ScoreManager] Unknown scoring type: ${t}. Valid types: average, weighted, custom.`)}}_calculateAverage(t){const e=Object.values(t);return e.length===0?null:e.reduce((a,s)=>a+s,0)/e.length}_calculateWeighted(t,e){let r=0,a=0;return e.forEach(s=>{const c=t[s.id];c!==void 0&&(r+=c*s.weight,a+=s.weight)}),a===0?null:r/a}_calculateMinimum(t){const e=Object.values(t);return e.length===0?null:Math.min(...e)}_calculateMaximum(t){const e=Object.values(t);return e.length===0?null:Math.max(...e)}_calculateCustom(t){try{const e=this.config.calculate(t);if(e==null)return null;if(typeof e!="number"||isNaN(e))throw new Error(`[ScoreManager] Custom calculate function must return a number or null. Got: ${typeof e}`);return e}catch(e){throw new Error(`[ScoreManager] Error in custom calculate function: ${e.message}`)}}recalculate(){if(!this.isInitialized)throw new Error("[ScoreManager] Cannot recalculate: not initialized. Call initialize() first.");this._calculateAndReportScore()}getCurrentScore(){if(!this.isInitialized)return null;const t=this._calculateScore();if(t===null)return null;const e=Math.round(t*100)/100;return{raw:e,scaled:e/100,sources:{...this.cachedScores}}}getSourceScores(){return{...this.cachedScores}}}const d=new l;export{d as default};
