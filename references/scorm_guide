# SCORM 2004 4th Edition Compliance Guide for E-Learning Content

This guide provides a comprehensive overview of **SCORM 2004 4th Edition** compliance requirements and best practices for course creators and AI tool developers. It is organized into three main sections corresponding to the SCORM specification books: **Content Aggregation Model (CAM)**, **Run-Time Environment (RTE)**, and **Sequencing and Navigation (SN)**. Each section includes detailed explanations of key concepts, structural breakdowns, and a compliance checklist to validate e-learning modules against SCORM 2004 4th Edition standards. The goal is to ensure clarity and accuracy for creating SCORM-conformant content packages, communicating with LMSs via the SCORM API, and implementing sequencing rules for consistent learner experiences across platforms.

### Content Aggregation Model (CAM)

The Content Aggregation Model defines how e-learning content is **structured, described, and packaged** for interoperability. It covers the SCORM content model (assets, SCOs, activities, etc.), how content is organized into a hierarchy, how content is packaged into a **manifest file**, and how metadata and application profiles ensure consistency. Following CAM guidelines ensures that content can be exchanged between systems and that its intended structure and behavior are preserved[\[1\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=3,content%20package%20also%20provides%20a)[\[2\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=SCORM%20Content%20Packaging%20is%20a,for%20packaging%20assets%2C%20SCOs%20and).

#### SCORM Content Model: Assets, SCOs, Activities, and Content Organizations

- **Asset:** An asset is the most basic content component, typically a single file or media element (text, image, audio, video, etc.). It is any electronic resource that can be delivered to a learner via a web client[\[3\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=2,In). Assets do **not** utilize the SCORM run-time API; they are not tracked for scoring or completion by the LMS. (For example, a plain HTML page or an image is an asset.) Assets can be reused and aggregated; multiple assets might be combined to form more complex content or even bundled as part of a SCO[\[4\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=The%20asset%20is%20the%20basic,part%20of%20the%20learning%20experience). Each asset can have metadata for search and reuse purposes.

- **Sharable Content Object (SCO):** A SCO is a collection of one or more assets that **forms a single launchable learning resource** which **does** communicate with the LMS via the SCORM API[\[5\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=2,the%20Institute%20for%20Electrical%20and). SCOs are the smallest units of content that are tracked by the LMS using the SCORM data model (e.g. each SCO can report status, score, etc.). The only difference between a SCO and an asset is the SCORM API communication – a SCO must initialize the API and can read/write data, whereas an asset cannot[\[6\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=learning%20resource%20that%20uses%20the,1%5D.%20Figure%202.1.2a%20below). Because of this, a SCO represents a logical "lesson" or modular piece of training that stands alone for tracking. SCOs should be context-independent to maximize reuse in different courses or learning contexts[\[7\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=To%20improve%20reusability%2C%20a%20SCO,For). SCORM **does not enforce a specific size or duration** for a SCO, but best practice is to keep SCOs small and focused (e.g. a single learning objective) to enable reusability[\[8\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=SCOs%20are%20intended%20to%20be,requirements%20for%20an%20organization%20will). Each SCO can also have metadata to describe its content for repositories.

- **Activity:** In SCORM 2004, an **activity** is an abstract unit of instruction – conceptually, "something the learner does"[\[9\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=A%20learning%20activity%20may%20be,A). Activities are represented in the content organization as a hierarchical structure. An activity may either be a **leaf activity** (which is linked to a SCO or asset that delivers content) or a **cluster** (an activity composed of sub-activities)[\[10\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=activities,be%20defined%20for%20activities%20and). Clusters serve as grouping nodes (e.g. a module or lesson containing multiple topics). There is no limit to the depth of nesting for activities; the hierarchy can represent courses, modules, lessons, etc., but SCORM itself is taxonomy-neutral (you can name levels as you wish)[\[11\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=which%20may%20themselves%20consist%20of,used%20to%20perform%20the%20activity). Leaf activities at the bottom of the hierarchy will have an associated SCO or asset to launch, while higher-level activities are organizational and have no content themselves. Like other components, activities can be tagged with metadata for reuse and discoverability. In sequencing, rules are applied to activities (including clusters) to determine the flow of the course.

- **Content Organization:** A content organization is essentially the **map or hierarchy of activities** that defines the structure of the learning experience[\[12\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=2,described%20with%20metadata%2C%20thereby%20enabling). It is represented in the SCORM manifest as an `` element (within ``). The content organization specifies how activities relate to each other (parent-child relationships) and the intended sequence or hierarchy in which content may be delivered. Only **one** organization is typically used to represent a course’s structure, though a manifest may include multiple organizations (e.g. to offer alternative sequences or curricula) – in such cases one is marked as the default for launch[\[13\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,Should%20be%20unique)[\[14\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,used%20in%20a%20meaningful%20manner). The organization contains the nested `` elements, each corresponding to an activity. This structure is also known as the **activity tree** at runtime (more on this in the Sequencing section). The content organization is where **sequencing rules** and navigation controls are attached to activities to guide how the learner can move through the content[\[15\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Sequencing%20only%20applies%20to%20activities,sequencing%20behaviors%20to%20control%20the). Importantly, the **LMS is responsible** for enforcing the defined sequence at runtime based on this structure – content developers outline the rules in the manifest, but do not hard-code sequencing into the SCO content itself[\[15\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Sequencing%20only%20applies%20to%20activities,sequencing%20behaviors%20to%20control%20the)[\[16\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Within%20SCORM%2C%20sequencing%20information%20is,This%20is). This separation of content from sequencing logic is a key design aspect of SCORM that improves interoperability and reuse.

- **Content Aggregation:** The term "content aggregation" refers to the process or the result of **collecting learning resources into a cohesive, deliverable unit (a content package)**[\[17\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=2,Sometimes%20the). In practice, a **content aggregation** is what we informally call a **SCORM package** – a set of SCOs and/or assets assembled into an organized course with a manifest. The content aggregation (often a .zip file containing the manifest and all content files) can be delivered, transferred, or stored as a single object. SCORM sometimes uses "content aggregation" interchangeably with "content package", though technically the aggregation is the conceptual collection and the package is the physical file. For course creators, the content aggregation step is about gathering all required assets/SCOs, structuring them via a content organization, and preparing the package for distribution.

#### Content Packaging and Manifests

To achieve interoperability, SCORM content must be packaged in a standardized way. This is done through the **IMS Content Packaging** specification (which SCORM leverages and profiles for its own needs). The centerpiece is the **XML manifest file (**`imsmanifest.xml`**)**, which describes the package contents, structure, and other required information.

**Manifest Structure:** The `imsmanifest.xml` file is an XML document with a well-defined structure. Key elements include:

- `` (root element) – must appear exactly once as the container for all packaging information[\[18\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=XML%20Binding%20Representation%3A%20,Resource%201%20and%20only%201). It has a unique identifier and may include a version. All other elements are nested inside.
- `` – (child of manifest) provides metadata about the package as a whole (often including the SCORM schema/version identifiers and optional descriptive metadata). For SCORM 2004, the manifest metadata should declare the SCORM schema and version (e.g., `ADL SCORM` and `2004 4th Edition`), and can include a pointer or embedded Learning Object Metadata (LOM) describing the course[\[19\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=elements.%20,section%20for%20a%20full%20description)[\[20\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=most%20manifests%20contain%20only%20one,ways%20the%20content%20in%20this).
- `` – a container for one or more content organizations (the logical structures of the content). Usually there is one organization per course. If multiple are present, the `default` attribute on `` indicates which one the LMS should launch by default[\[13\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,Should%20be%20unique)[\[14\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,used%20in%20a%20meaningful%20manner).
- `` – defines a specific structured view of the content, typically corresponding to a course or curriculum. It has its own identifier and contains the hierarchical `` elements that represent the activities and map to content.
  - `` – represents an activity (cluster or leaf). Items can be nested (child `` inside a parent `` for sub-activities) to any depth. Each `` may have:
  - `identifier` (unique within the manifest) and a human-readable `` for the activity.
  - `identifierref` (on leaf items) which references the ID of a **resource** (in the resources section) that delivers the content for that item[\[21\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,should%20be%20passed%20to%20an)[\[22\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,not%20contain%20an%20identifierref%20attribute). Only leaf items (no child sub-items) should have an `identifierref` – those are the ones tied to an asset or SCO. Items that are clusters (with children) typically do *not* have an `identifierref` (they don’t launch content themselves).
  - `isvisible` (optional) to control whether the item is shown in the LMS’s course menu or table of contents (useful for hidden assessment items, etc.).
  - `parameters` (optional) to supply query string parameters to the content at launch (for dynamic content behavior).
  - `` children – any number of nested activities.
  - `` (optional) – to provide metadata specific to that activity (rarely used, but can embed or reference a LOM description for the item).
  - Sequencing and navigation elements – (optional) SCORM-specific sequencing definitions within an `` element attached to the item (see Sequencing section for details).
  - Additional SCORM-specific extensions in the item, like `` in SCORM 2004 3rd Ed and earlier (note: in 4th Ed, prerequisites are expressed via sequencing rules rather than a dedicated element), or time limit and data for LMS (e.g., ``, ``, `` etc., which initialize certain run-time data model values like time limit behavior, launch data, and completion criteria)[\[23\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,Similar%20to%20the%20parameters%20attribute)[\[24\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=metadata%20section%20for%20a%20full,0%3A1%5DThe%20minimum%20threshold%20of%20progress).
- `` – a list of all **physical content resources** in the package. This tells the LMS which files to launch for each SCO or asset, and where to find all asset files.
- `` – defines a logical resource, typically corresponding to a SCO or an asset or a shared asset pool. Each resource has:
  - `identifier` (unique id, which `identifierref` on an item links to).
  - `adlcp:scormType` – either `"sco"` for a launchable SCO resource or `"asset"` for a resource that is an asset or asset collection[\[25\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=application%20profiles%2C%20of%20the%20IMS,for%20packaging%20assets%2C%20SCOs%20and)[\[26\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Section%203,Guidelines%20defines%20a%20collection%20of). This distinguishes trackable vs. untrackable content.
  - `href` – (for SCOs or standalone assets) the default launchable file (e.g., the HTML file that should be loaded when the SCO is launched). Assets that are not directly launched might omit href and just list files.
  - A set of `` children that enumerate the actual files included for that resource (HTML, JS, media, etc.). Every file used by the content should be listed in some `` entry so that the package is complete.
  - Optional `` elements if a resource relies on another resource (for example, a SCO might depend on a shared asset resource like a media library).
- (Optional) `` – SCORM 2004 allows defining reusable sequencing rulesets that can be referenced by items in the organization. In practice this is not commonly used, as sequencing is usually defined inline on each item, but the manifest can include a library of sequencing definitions.

All these manifest elements must follow the SCORM Application Profile, which imposes specific rules on their **multiplicity** and usage. For example, in a **Content Aggregation Package** (a package with an organization): there must be exactly one root ``, one `` element, at least one `` with at least one ``, and one `` listing all content. Each `` that is a leaf must reference a ``, and each `` that is launchable (SCO) should be referenced by an item (unused files are generally not recommended). Conversely, in a **Resource Package** (see Application Profiles below), there would be no `` at all – just a `` list (used for a standalone media collection or a library of SCOs without a defined sequence)[\[27\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Application%20Profiles%3A%20%E2%80%A2%20Resource%20Content,Profile%3A%20A%20content%20package%20for)[\[28\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20Resource%20Content%20Package%20Application,Profile%3A%20A%20content%20package%20for).

**Application Profiles:** SCORM 2004 defines two packaging profiles to accommodate different needs[\[27\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Application%20Profiles%3A%20%E2%80%A2%20Resource%20Content,Profile%3A%20A%20content%20package%20for)[\[28\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20Resource%20Content%20Package%20Application,Profile%3A%20A%20content%20package%20for):

- **Content Aggregation Content Package** – a package that *includes* a content structure (one or more organizations) along with resources. This is the typical “course” package with a defined sequencing and hierarchy. In this profile, an `` is required (1 or more organizations) and represents the intended static structure/sequence of the content[\[29\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=content%20structure,Profile%3A%20A%20content%20package%20for).

- **Resource Content Package** – a lighter package that contains only the `` (a collection of SCOs and/or assets) *without* any organization or sequencing[\[27\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Application%20Profiles%3A%20%E2%80%A2%20Resource%20Content,Profile%3A%20A%20content%20package%20for)[\[28\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20Resource%20Content%20Package%20Application,Profile%3A%20A%20content%20package%20for). This can be used to exchange a library of content objects or assets for reuse, which an LMS or authoring tool could later insert into an organization. In such a package, the `` element would not be present (or empty), and the profile allows that. Essentially it’s just a bundle of content with no predefined course structure.

The manifest must declare which profile it follows by including the appropriate elements (the SCORM Application Profile is validated by checking the presence/absence and counts of certain elements). For example, in a Content Aggregation package, exactly one `` is typically expected, whereas in a Resource package zero organizations are allowed[\[30\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Application%20Profiles%3A%20%E2%80%A2%20Resource%20Content,with%20no%20defined%20organization%20or)[\[31\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20Content%20Aggregation%20Content%20Package,Profile%3A%20A%20content%20package%20for). (The SCORM specification includes tables of these requirements to ensure compliance.)

**Metadata:** Metadata is information that describes the content for purposes like search, discovery, and reuse. SCORM uses IEEE **Learning Object Metadata (LOM)** as the basis for its metadata requirements. Metadata can be applied at multiple levels in SCORM packages:

- **Package (Manifest) Metadata:** Descriptive info about the content package as a whole (typically includes at least the course title, language, description, keywords, etc.). This is often embedded in the `/` element or provided by reference (using `` to point to an external .xml metadata file). Many authoring tools allow entering course metadata that ends up here.

- **Organization and Item Metadata:** You can attach metadata to specific organizations or items (activities) via their `` sub-elements. This could describe a module or lesson in more detail, but it’s optional and rarely used in practice.

- **Resource (SCO/Asset) Metadata:** Each `` can have a `` section to describe the SCO or asset files. In particular, each SCO should have metadata indicating its educational context, duration, difficulty, etc., to facilitate reuse. Assets too can have metadata (e.g., if an image is reusable learning media, metadata might describe it).

All metadata in SCORM 2004 4th Ed is typically formatted as LOM XML (sometimes through an **IMS manifest extension** using `` tags or externally referenced). The SCORM CAM specification details how to use LOM elements and even allows for extensions and multiple strategies for metadata validation (strict, loose, custom)[\[32\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=4,146%204.5.4.%20Metadata%20Describing%20SCOs)[\[33\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=4,147%204.5.5.%20Metadata%20Describing%20Assets). While SCORM does not *mandate* extensive metadata, providing rich metadata is a best practice for enabling content libraries and AI tools to discover and assemble content intelligently.

**Best Practices and Guidelines (Packaging):**

- **Use Unique Identifiers:** Ensure every manifest element that requires an identifier (`manifest`, `organization`, `item`, `resource`, etc.) has a unique ID (often tools generate GUIDs). This avoids conflicts when merging content and is required for manifest validity[\[34\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Attributes%3A%20%E2%80%A2%20identifier%20,The%20identifier%20attribute%20is%20typically).

- **Follow XML Schema and SCORM Profiles:** The manifest should validate against the SCORM 2004 4th Edition XML schemas. Use the correct XML namespaces for SCORM (e.g., `adlcp`, `imsss`, `adlseq`, `adlnav` schemas as needed) and include the schema location hints if required. While the detailed schema syntax isn’t included here, be aware that SCORM 2004 4th Edition introduced updated namespace URIs (like `adlcp:scormType` with value "sco" or "asset", etc.). Using the ADL-provided sample manifest as a template can help.

- **Do Not Use Deprecated Elements:** SCORM 2004 4th Ed phased out some older SCORM 1.2 practices (like the old `prerequisites` syntax or `item parameters` for scoring). Instead, use the sequencing and data model features of SCORM 2004 (e.g., use sequencing rules for prerequisites). ADL also **recommends avoiding sub-manifests** (nested `` elements inside the root manifest) for SCORM 2004, as support for them is not required and they complicate packaging[\[35\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=ADL%20Note%3A%20The%20IMS%20Global,sub%29manifests). Stick to a single manifest per package.

- **Include All Required Files:** Ensure every file needed by the content (HTML, media, JS, etc.) is listed in a `` element under some ``. This guarantees the package is self-contained. Unreferenced files might be ignored by some LMSs or might cause validation warnings.

- **SCORM-specific Metadata:** The manifest’s `` should include the SCORM schema declaration:

- `ADL SCORM` and `2004 4th Edition` (or similar) to declare the SCORM version[\[20\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=most%20manifests%20contain%20only%20one,ways%20the%20content%20in%20this)[\[36\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,to). This helps an LMS or tool recognize the package as SCORM 2004 4th Ed.

- **Application Profile Selection:** If you intend your package to be launched as a course, use the Content Aggregation profile (include an organization). If you're just creating a library of content objects for others to use, the Resource package is appropriate. Some packaging/validation tools may ask which profile you are using.

- **Testing Package Validity:** Use ADL’s SCORM Test Suite or other SCORM validators to test your package. They will catch schema errors, missing files, incorrect multiplicity (like an item missing an identifierref or multiple defaults, etc.), ensuring the content package meets SCORM requirements.

##### CAM Compliance Checklist (Content Packaging & Structure)

- **Manifest and File Structure:** The content is packaged with a single `imsmanifest.xml` at the root of the package (e.g., in a ZIP). The manifest exists **once** and declares the SCORM 2004 4th Edition schemaversion[\[18\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=XML%20Binding%20Representation%3A%20,Resource%201%20and%20only%201)[\[37\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=SCORM%20Requirements%3A%20The%20manifest%20element,Parent%20elements%20have%20no). All content files are included in the package and referenced in the manifest.

- **Organization and Item Hierarchy:** If the package is a course, there is at least one `` defined under `` (and one marked as default if multiple). The organization’s items form a logical hierarchy (course map). Every leaf `` (no children) has an `identifierref` pointing to a valid `` in the resources list. Non-leaf items do not have `identifierref` (they are purely structural). All items have unique identifiers and titles.

- **Resources and Assets:** Every `` has a unique identifier and a correct `adlcp:scormType` ("sco" for trackable content, "asset" for assets)[\[25\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=application%20profiles%2C%20of%20the%20IMS,for%20packaging%20assets%2C%20SCOs%20and). Launchable SCOs have an `href` pointing to the startup HTML (or other launch file). All file entries needed for each resource are listed. No missing media or dependencies.

- **SCORM Profile Conformance:** The manifest obeys the SCORM Content Package Application Profile rules for either a **Content Aggregation** or **Resource** package. For example, a Content Aggregation package will include an `` (1 or more) and exactly one root manifest, etc., whereas a Resource package will have no organization (just resources)[\[27\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Application%20Profiles%3A%20%E2%80%A2%20Resource%20Content,Profile%3A%20A%20content%20package%20for)[\[28\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20Resource%20Content%20Package%20Application,Profile%3A%20A%20content%20package%20for). There are no forbidden elements present (e.g., no SCORM 1.2 elements like `<>` that are not part of SCORM 2004).

- **Metadata Inclusion:** The manifest contains the SCORM schema/version metadata. If required by your organization or project, descriptive metadata (LOM) is included for the package and/or individual components to facilitate discovery. (Not strictly required by SCORM for runtime, but good practice.)

- **No Sub-manifests:** The package does not use nested manifests unless absolutely necessary. (SCORM 4th Ed does not require LMS support for sub-manifests[\[38\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=2,sub%29manifests), so using them may hinder interoperability.)

- **Validation:** The package has been tested with a SCORM 2004 4th Edition validator or sample run on a SCORM-conformant LMS. The manifest is well-formed XML and schema-valid, ensuring any LMS can import it without errors.

By following the above, content creators ensure that their content package can be imported and understood by any SCORM 2004 conformant Learning Management System (LMS), preserving the intended course structure and content.

### Run-Time Environment (RTE)

The Run-Time Environment governs how SCO content **communicates with the LMS** during execution. It includes the SCORM **API** that SCOs use to initialize, exchange data, and terminate properly, as well as the definition of the **SCORM Data Model** (the specific data fields that can be read/write, e.g., completion status, scores, bookmarks, etc.). This section also clarifies the **responsibilities of the LMS and the SCO** at runtime, and the typical communication flow from launch to finish. Ensuring compliance with RTE means a SCO can reliably track learner progress and outcomes on any conformant LMS, and that the LMS manages and stores data consistently.

#### SCORM API Overview and Launch Process

In SCORM 2004, when a learner launches a SCO, the LMS is responsible for providing a **Run-Time API** (typically a JavaScript object in the browser) that the SCO can call. The API object implements a set of functions (also defined in IEEE standard 1484.11.2) that allow two-way communication between content and LMS[\[39\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=provide%20the%20means%20for%20SCORM,the%20SCORM%20RTE%20Data%20Model)[\[40\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=The%20SCORM%20RTE%20Data%20Model%2C,have%20impacts%20on%20the%20SCORM).

**API Object & Functions:** The standard API functions in SCORM 2004 include: - **Initialize("")** – Initializes communication with the LMS (must be called by the SCO at the start of an attempt). - **Terminate("")** – Terminates communication (called when the learner is done with the SCO, e.g., on exit). - **GetValue(element)** – Retrieves the value of a data model element (for reading data from LMS, e.g., prior completion status, or preferences). - **SetValue(element, value)** – Assigns a value to a data model element (for sending data to LMS, e.g., score or completion flag). - **Commit("")** – Forces the LMS to persist any data changes (useful to save interim data during a long SCO, not always required since Terminate will also commit any unsaved data). - **GetLastError()** – Returns the last error code from a previous API call. - **GetErrorString(errorCode)** – Returns a human-readable description for a given error code. - **GetDiagnostic(errorCode)** – Returns LMS-specific diagnostic info about an error (typically not used often).

These functions allow the SCO to perform the basic "handshake" with the LMS[\[39\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=provide%20the%20means%20for%20SCORM,the%20SCORM%20RTE%20Data%20Model)[\[40\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=The%20SCORM%20RTE%20Data%20Model%2C,have%20impacts%20on%20the%20SCORM) – initializing a session, reading any initial state, reporting results, and closing the session. The functions take and return character strings (as per the SCORM specification) and use specific return conventions (“true”/“false” for success on Initialize/Terminate/Commit, empty string for GetValue errors, etc.) as defined in the standard.

**Launch Sequence:** A typical SCORM launch and run-time sequence is as follows: 1. **Content Launch:** The LMS delivers the SCO’s launch file (e.g. opens the SCO’s HTML in a new window or frame) and *provides the API connection*. Usually, the LMS places a JavaScript API object in the browser (commonly accessible via `window.parent` or `window.opener` as `API_1484_11` or similar). The SCO content (which is usually HTML/JS) must locate this API object through the window hierarchy. 2. **SCO Initialization:** The SCO, once ready, calls `Initialize("")` exactly **one time** to start the communication session[\[41\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=A%20SCO%20is%20required%20to,the%20nature%20of%20the%20content). The LMS should respond with "true" if initialization is successful. Calling Initialize establishes the session state (the LMS may load initial values into memory, mark the attempt as active, etc.). If the SCO fails to call Initialize, or calls it incorrectly, no data exchanges can happen. Only certain methods are allowed before Initialize (essentially none, except the error checking ones in some cases) – all Get/Set calls will fail if the session is not initialized (error 301 or 401 range errors). 3. **Data Interaction:** After initialization, the SCO can use `GetValue()` to read run-time data (for example, get the learner’s name, or retrieve a bookmark from a previous session via `cmi.location`). It can use `SetValue()` to send any data as the learner progresses (such as updating `cmi.score.raw` as a quiz is graded, or setting `cmi.exit` to "suspend" if the learner chooses to pause). These calls manipulate the **SCORM data model elements** (explained in next subsection). The LMS handles each call by getting or storing the data and returns control to the SCO. During this phase, the SCO should also monitor errors (via `GetLastError`) after each call in case something went wrong (e.g., writing to a read-only field). 4. **Commit (optional):** The SCO may periodically call `Commit("")` to ask the LMS to persist the data to permanent storage. SCORM requires that the LMS treat Terminate as an implicit Commit, so if the SCO never calls Commit during runtime, all data will still be saved at Terminate. However, for long SCO sessions or important data, Commit is good practice to avoid data loss if the session is unexpectedly interrupted (network issues, etc.). The LMS returns "true" if commit succeeded. 5. **Termination:** When the learner is finished with the SCO (either completes it, closes it, or navigates away), the SCO must call `Terminate("")` to gracefully close the session. This signals the LMS that the attempt on the SCO is over and the data can be finalized. Upon Terminate, the LMS will persist any unsaved data (essentially doing a final Commit), and then return "true" if all went well. After a successful Terminate call, the SCO is only allowed to call the error diagnostic functions; any further GetValue/SetValue calls will be rejected (error 113, "Termination After Termination")[\[42\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=3,The%20API%20Instance)[\[43\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=The%20Termination%20After%20Termination%20error,The%20API%20Instance). If Terminate fails (returns "false"), the SCO might attempt it again or at least log the error, but generally a "false" indicates a serious issue (like LMS couldn’t save data). 6. **Unload:** After Terminate, the SCO page can safely be closed or redirected. The LMS may at that point trigger the next SCO to launch (if there is a next item per sequencing) or end the session if the course is completed.

Throughout this process, error codes and handling are defined by SCORM. For example, if `Initialize` is called twice without Terminate, the LMS must return "false" and error 103 (Already Initialized)[\[44\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=shall%20remain%20unchanged%20%28%E2%80%9CNot%20Initialized%E2%80%9D%29,%E2%80%9C%E2%80%9D%29%20%29%20more)[\[45\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=The%20Already%20Initialized%20error%20condition,shall%20be%20used%20when%20the); if `GetValue("someInvalidElement")` is called, the LMS returns an error 401 (Unknown Data Element). It is critical for both SCO and LMS to implement these rules to avoid crashes or inconsistent data. The SCO should be coded to at least catch the common errors (like 101 General Error, 201 Invalid Argument, 301 Not Initialized, etc.) and react appropriately (perhaps alert the user or attempt recovery).

**API Instance Discovery:** It’s worth noting that the SCORM specifications assume a web browser environment and the API is typically a JavaScript object named `API_1484_11` for SCORM 2004 (and/or `API` for SCORM 1.2) provided by the LMS in the opener or parent frame. A SCO must have a mechanism (usually a small JavaScript function) to search up the `window` hierarchy to find this object. This is often provided by SCORM wrappers or the authoring tool. If the API cannot be found, the SCO cannot communicate. So part of being SCORM-compliant is ensuring your SCO includes the standard API discovery algorithm.

#### SCORM Data Model (Run-Time Data)

The SCORM RTE Data Model is a collection of data elements that represent the state of the learner’s attempt and performance within a SCO, as well as some LMS-controlled settings. These data model elements are accessed via the API’s GetValue and SetValue calls using **dot notation strings** like `"cmi.completion_status"` or `"cmi.score.scaled"`. SCORM 2004 aligns with the IEEE Data Model standards (1484.11.1) and defines specific elements (some required, some optional) that an LMS must support. Key data model elements include:

- **cmi.exit:** (write-only) Indicates how the learner exited the SCO. Common values are:

- `"normal"` – the learner completed the SCO normally (not planning to return to this same attempt).

- `"suspend"` – the learner has paused the attempt and will resume later (this tells the LMS to preserve state for resumption).

- `"logout"` – the learner logged out while in the SCO.

- `""` (empty string) – if the SCO is completing without any special condition (often treated same as "normal").  
  The SCO should set `cmi.exit` before Terminate if it wants to suspend. If `cmi.exit` is left empty or "normal", the attempt is considered finished.

- **cmi.entry:** (read-only) Indicates how the SCO is being entered. After a normal completion, if the learner launches the SCO again in a new attempt, `cmi.entry` will be `"ab-initio"` (or simply empty in some specs) meaning a fresh start. If the learner is returning to a suspended attempt, `cmi.entry` will be `"resume"`, indicating the SCO should resume from where it left off (the SCO can then fetch bookmark data, etc.). The LMS sets this value at launch.

- **cmi.location:** (read/write) A bookmark or location string the SCO can use to mark the learner’s position (e.g., page number or topic ID). If a SCO wants to enable “resume where you left off”, it should periodically save a value to `cmi.location` (up to 1000 characters). On re-entry (`cmi.entry = resume`), the SCO can read `cmi.location` to jump to that point in the content.

- **cmi.completion_status:** (read/write) The completion state of the SCO for this attempt. SCORM 2004 defines values: `"not attempted"`, `"incomplete"`, `"completed"` (and `"unknown"` as an initial placeholder). The LMS will initialize this to `"not attempted"` at first launch of an attempt. The SCO is responsible for setting this to `"completed"` or `"incomplete"` by the end of the attempt, unless the course is tracking completion in some automated way via objectives (more on that in SN). If `completionSetByContent` (from sequencing/delivery controls) is false, some LMS might auto-set completion when the SCO terminates; but best practice is for the SCO to explicitly set completion. **Completion** generally indicates whether the learner finished the content in a structural sense (viewed all, or reached end).

- **cmi.success_status:** (read/write) The success or result of the SCO attempt, with values: `"passed"`, `"failed"`, or `"unknown"`. This is typically used for scored content or assessments. The SCO should set this to "passed" or "failed" based on the learner’s achievement. If the SCO doesn’t set it, and if the LMS has a mastery score defined for this SCO (via manifest `scaled_passing_score` in the objective), the LMS may determine success after the attempt by comparing score to threshold[\[46\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=Dot,IMS%20Simple%20Sequencing%20namespace%20attribute)[\[47\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=imsss%3AsatisfiedByMeasure%20associated%20with%20the%20,be%20initialized%20to%20any%20value). If `objectiveSetByContent` is false (meaning content is not explicitly setting success), the LMS will use the score and mastery rules to set it[\[48\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=%E2%80%A2%20If%20the%20IMS%20Simple,imsss%3AprimaryObjective)[\[49\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=to%20false%2C%20then%20the%20LMS,the%20error%20code%20to%200). If neither content nor LMS has info, it might remain "unknown".

- **cmi.score.**\* – There are four score sub-elements:

- `cmi.score.raw` (read/write, decimal or integer) – the raw score the learner achieved (in the SCO’s own terms, e.g., 85 out of 100 points).

- `cmi.score.max` and `cmi.score.min` (read/write, decimals) – the maximum and minimum raw score possible. These contextualize the raw score (e.g., min 0, max 100).

- `cmi.score.scaled` (read/write) – a normalized score from -1.0 to 1.0. Typically this is the raw score normalized to 0–1 range (so an 85/100 would be 0.85). The scaled score is often used by the LMS to judge mastery against a passing threshold of 0–1.

The SCO can set any or all of these. Many SCOs just set raw (and maybe max) and let the LMS compute scaled. But if a manifest defined a `scaled_passing_score`, the LMS expects scaled values for comparison. **Note:** If `completion_status` is separate from success, a SCO could be completed but failed (finished an exam but didn’t pass).

- **cmi.scaled_passing_score:** (read-only) If defined in the manifest (as `` in older SCORM or via the primary objective in 2004 sequencing), the LMS will initialize this element to the required passing score for the SCO, scaled 0–1[\[46\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=Dot,IMS%20Simple%20Sequencing%20namespace%20attribute)[\[49\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=to%20false%2C%20then%20the%20LMS,the%20error%20code%20to%200). The SCO can read this via GetValue to know what “passing” means (e.g., 0.8 means 80% is needed). The SCO cannot modify it (SetValue on a read-only like this yields error 404)[\[50\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=the%20SCO%20requests%20the%20value,Example)[\[51\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=Value%20Not%20Initialized%20and%20return,element%20based%20on%20the%20request).

- **cmi.session_time:** (write-only) The amount of time the learner spent in the SCO *in this session*, to be reported when ending. The SCO should accumulate the time the user spent and before calling Terminate, call `SetValue("cmi.session_time", sessionDuration)`. The format for session_time in SCORM 2004 is a time interval formatted as **HH:MM:SS.sss** or as a ISO8601 duration (the spec allows a certain format, e.g., `PT1H30M5S` for 1h30m5s – check SCORM reference for exact format). This allows the LMS to add this to the total time.

- **cmi.total_time:** (read-only) The total accumulated time the learner has spent in this SCO across all attempts (or including resumed sessions). The LMS maintains this. The SCO cannot change it; it can only read it if needed (not commonly used by content).

- **cmi.suspend_data:** (read/write, up to 64k characters) A chunk of data that the SCO can use to store arbitrary state for resume. This is critical for bookmarking complex state (like test item responses, interactive variables, etc.). When a SCO is resumed after a suspend, it can retrieve this data to restore the learner’s state. It’s opaque to the LMS (just stored and retrieved).

- **cmi.interactions.\*:** (read/write) An array of interaction records that the SCO can use to report question/response details. Each interaction (cmi.interactions.n) can include sub-elements like ID, type (e.g., true-false, choice, fill-in), learner’s response, result (correct, wrong, etc.), the question text or indicator, correct answers, feedback, timestamp, etc. Interactions are useful for detailed reporting (like an LMS quiz report). SCORM allows a large number of interactions per SCO (usually at least 250 or more) and each field has length limits. If used, each interaction must be created via SetValue with an index (like "cmi.interactions.0.id", etc.). This is optional but part of the spec.

- **cmi.objectives.\*:** (read/write) An array of objectives (besides the primary implicit objective which is the SCO’s overall status). Each objective can have an id, a score, success status, completion status, etc. This is mostly used if a single SCO tracks multiple goals or sub-objectives. Objectives can also map to global objectives shared across SCOs (via the manifest sequencing definitions). This is an advanced feature; if a SCO doesn’t need it, you can ignore objectives array aside from the primary one represented by success/completion status above.

- **cmi.completion_threshold:** (read-only) If defined, indicates the threshold of progress (e.g. 1.0 or 0.5) required to consider the SCO "completed" if using progress measure. (This is tied to sequencing when using measure-based completion instead of the SCO explicitly marking complete.)

- **cmi.progress_measure:** (read/write) A value 0.0–1.0 indicating how far along the learner is in the SCO. A SCO that tracks its own progress (say it has 10 screens, and the learner viewed 5, so progress_measure = 0.5) can set this. If a completion threshold is set (say 0.8), the LMS could automatically mark complete when progress \>= threshold. This is optional and used in certain cases to automate completion.

- **cmi.learner_id / cmi.learner_name:** (read-only) Identifiers for the learner. `learner_id` is an LMS-specific unique id for the student (often a number or username). `learner_name` is typically the display name (like "John Doe"). Useful if the content wants to personalize itself ("Welcome, \[name\]").

- **cmi.credit:** (read-only) Indicates whether the learner is taking this SCO for credit or just practice. Values: "credit" or "no-credit". Content can check this and decide whether to record scores etc. The LMS sets it based on context (e.g., if the course is being audited vs taken for credit).

- **cmi.mode:** (read-only) Indicates mode of launch: "normal", "review", or "browse".

- "normal" is a typical launch with tracking.

- "review" means the learner already completed it and is just viewing without changing results (SCO might disable some interactions or at least not change the score).

- "browse" means a preview mode where certain data might not be tracked. SCORM 2004 rarely uses browse, but it’s in the spec.

- **cmi.launch_data:** (read-only) If the manifest provided any parameters via `` for this SCO, they appear here. The SCO can retrieve this string and use it. For instance, an author might supply config data to the SCO through the manifest (e.g., to tell a generic SCO which lesson to load).

- **adl.nav.request:** (write-only, SCORM extension for navigation) – This is part of the SCORM Navigation data model. A SCO can set this element to a navigation request value (before Terminate) to ask the LMS to do something once the SCO closes. For example, setting `adl.nav.request` to “continue” means “when I finish (Terminate), auto-move to the next activity” or "previous" to move back, or “exit” to exit course, “exitAll” to finish all, etc. The content uses this if it has internal navigation controls and wants to direct the LMS. Valid values include: `continue`, `previous`, `exit`, `exitAll`, `start`, `resumeAll`, or `choice={target=}` for jumping, and `suspendAll`. The LMS will carry out the request after Terminate (if allowed by sequencing). The SCO should check via `adl.nav.request_valid` (read-only) what requests are valid at the moment (e.g., if there’s no “previous” to go to, `request_valid.previous` would be false). Using this mechanism allows SCOs to drive course navigation seamlessly (this is an advanced feature linking to SN).

- **adl.nav.request_valid:** (read-only) – an array of booleans indicating which navigation requests are currently available (e.g., Continue, Previous, Exit, etc.). A SCO may read these to decide whether to show its own "Next" button, for example. This prevents offering a navigation that would result in an error (like a Next when at end of course).

All SCORM data model elements have defined data types, default values, and constraints. For instance, many string elements have a maximum length (SPM – smallest permitted maximum – e.g., suspend_data is 64k, interactions IDs maybe 255 chars, etc.) and if a SCO exceeds that length in SetValue, the LMS should throw an error (error 405 Data Model Element Value Out Of Range). The **LMS is responsible** for initializing all data model elements at the start of an attempt with appropriate defaults (e.g., completion_status to "not attempted", attempt count to 0, etc., per spec)[\[52\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=LMS%20Behavior%20Requirements%3A%20%E2%80%A2%20The,imsss%3AprimaryObjective)[\[53\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=imsss%3AsatisfiedByMeasure%20associated%20with%20the%20,scaled_passing_score%20data%20model%20element). The LMS must also enforce read-only vs read/write (so content cannot change things like learner_id or scaled_passing_score)[\[54\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=%E2%80%A2%20The%20data%20model%20element,Data%20Model%20Element%20Implementation%20Requirements)[\[51\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=Value%20Not%20Initialized%20and%20return,element%20based%20on%20the%20request). Meanwhile, the **SCO is responsible** for using the data model correctly: only using defined elements, providing values in the correct format (e.g., "PT0H0M30S" for 30 seconds if ISO format is required, or "30" for 30 seconds if another format, depending on SCORM definition), and not exceeding lengths.

#### LMS vs SCO Responsibilities

It’s important to delineate what the LMS must do versus what the SCO (content) must do for run-time compliance:

**LMS Responsibilities:** - **Provide the API Implementation:** The LMS (or learning platform) must make the SCORM API available to the content. This includes implementing all the functions (`Initialize`, `GetValue`, etc.) with the behaviors specified by SCORM. The LMS needs to handle function call sequences, manage the underlying data model state, and return proper error codes/messages. For example, the LMS must track whether `Initialize` was called; if a `SetValue` comes in before initialization, it should fail with error 132 (not initialized). - **Launch and Close Content:** The LMS launches SCOs in a web browser window/frame and ensures the API is accessible (often by having an API object in the opener window or frameset). It must also detect when a SCO has finished (usually after Terminate returns true, or if the window unexpectedly closes, the LMS may have to handle that as a lost connection). - **Initialize Data Model for Attempts:** When a new attempt on a SCO begins, the LMS sets initial values for each data model element per SCORM rules (e.g., `cmi.score` fields blank or 0, `cmi.completion_status` = "not attempted", etc.). If resuming a suspended attempt, the LMS restores the saved values from last session (e.g., the suspend_data, the previously recorded progress, etc.). This ensures the SCO’s GetValue calls return the right starting data. - **Enforce Data Model Rules:** The LMS must only allow valid data model elements and enforce read-only rules. It should return error 404 for writes to read-only elements[\[50\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=the%20SCO%20requests%20the%20value,Example), error 401 for unknown element names, error 406 for writing a value with wrong format/type, etc. It should also handle the cardinality of collection elements (e.g., if only 10 interactions are allowed and the SCO tries to create 11th, LMS should error). - **Store and Persist Data:** The LMS acts as the persistent store for SCO data. Each time SetValue is called (and especially on Commit/Terminate), the LMS saves that data (to a database or session store). It must preserve data between sessions when appropriate: for example, if the learner suspends a SCO, all the data (interactions, suspend_data, etc.) must be available on resume. If the learner finished the SCO, the data is frozen for that attempt, and possibly used for scoring and roll-up. - **Error Reporting:** The LMS should provide meaningful error codes and diagnostic messages to the SCO on request. SCORM defines specific codes 0 (no error) up to various ranges for general, initialization, termination, gets/sets, etc. The LMS sets an internal last error state each time a call is made, which the SCO can query via GetLastError. For instance, after a successful SetValue, GetLastError should be 0. If a SCO asks for something invalid, LMS might set error like 403 (element not initialized) and the SCO can then call GetErrorString(403) to get a text like "Data Model Element Value Not Initialized"[\[55\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=%E2%80%A2%20GetValue,%E2%80%9C%E2%80%9D). - **Maintain Session State:** The LMS conceptually has states for the communication session: Not Initialized, Running (after Init called), Terminated (after termination). It should not allow invalid state transitions (e.g., double Init, or Terminate before Init). The spec defines how LMS should react if these happen (set error codes like 103 for double init[\[44\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=shall%20remain%20unchanged%20%28%E2%80%9CNot%20Initialized%E2%80%9D%29,%E2%80%9C%E2%80%9D%29%20%29%20more), 112 for Terminate before Init[\[56\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=SCO,when%20the%20SCO%20tries%20to)[\[57\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=The%20Termination%20Before%20Initialization%20error,The%20API%20Instance), etc., and not change state on those errors). - **Sequencing and Next SCO Launch:** Once a SCO is terminated, the LMS then uses the Sequencing & Navigation rules (next section) to determine the next activity to deliver (if any). The LMS is responsible for taking any `adl.nav.request` the SCO made into account and executing the appropriate navigation. Essentially, the LMS orchestrates moving through the activity tree, while the SCOs just report data.

**SCO (Content) Responsibilities:** - **Find and Connect to the API:** The SCO content must include the logic to search for the API object and properly call the SCORM API functions. Without this, the SCO cannot communicate. This typically means including the SCORM runtime wrapper script or code from the authoring tool. - **Call Initialize and Terminate**: A SCO **must call** `Initialize("")` at the beginning of use and `Terminate("")` at the end of the session[\[41\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=A%20SCO%20is%20required%20to,the%20nature%20of%20the%20content). Forgetting these calls means the LMS may not record any data (and the attempt may not be marked as started or ended properly). Also, call each exactly once per attempt. (Multiple inits or missing terminate are violations of SCORM runtime usage.) - **Perform Get/Set Calls Appropriately:** The SCO should retrieve any needed initial state *after* initialize (e.g., prior score or bookmark) via GetValue, and it should send status, score, and progress data via SetValue as the user goes through the content. It should only use valid element strings and obey the data formats. For instance, use `"passed"`/`"failed"` not older terms like "pass"/"fail"; use "completed"/"incomplete" etc., and ensure numeric values are in allowed range. - **Update Mandatory Tracking Data:** While SCORM 2004 doesn’t force every SCO to set all values, it’s a best practice that the SCO **at least sets a completion status** and/or success status by the end. If a SCO never calls SetValue for `cmi.completion_status`, the LMS will consider it "not attempted" or "incomplete" by default. Similarly, if it never reports score or success, the LMS might not know if the learner passed. So content developers should ensure these are handled: - If the SCO is purely informational with no quiz, it can simply set completion to "completed" when the learner finishes viewing it (and possibly success to "passed" by default or leave it unknown if not applicable). - If the SCO is an assessment, it should set the score and success=passed/failed accordingly, and completion status "completed" when done. - **Handle Session Time:** The SCO should keep track of time and set `cmi.session_time` before terminating. Many authoring tools do this automatically. If not set, the LMS may not add any time for that attempt. - **Use Suspend Data for Resumability:** If the SCO is resumable (the learner can come back later), the SCO must set `cmi.exit = "suspend"` on exit and use `cmi.suspend_data` to store state. On re-entry (`cmi.entry = "resume"`), the SCO should read `cmi.suspend_data` and restore state (like jump to last page, etc.). If the SCO doesn’t manage this, the learner might have to restart from scratch each time. - **Adhere to Data Limits:** The SCO should not overflow the data model limits (for example, not store an extremely large string into suspend_data beyond 64k, or a 500-character response if max is 255). If using interactions, each needs a unique id and cannot exceed the count limit. Tools usually ensure this, but custom-developed SCOs must be mindful. - **Error Checking:** The SCO should call `GetLastError()` after critical calls. At minimum, it should check that Initialize returned "true" and handle "false" by perhaps trying again or aborting gracefully with a message to the user that the session couldn’t start. Similarly, if a SetValue returns "false", the SCO might log or display an error (e.g., if trying to set a read-only element, the developer should fix the SCO code). - **No LMS Calls**: The SCO should not attempt to call or interact with LMS systems other than through the SCORM API. SCORM prohibits, for example, directly accessing LMS databases or assuming anything about the environment aside from the API. - **Stay Running Until Terminate:** Ideally, the SCO should not self-close or navigate away from the provided launch window without calling Terminate. If the user clicks a close button that just closes the window, the SCO should have called Terminate in that button’s handler first. Failing to Terminate can lead to the LMS not saving data (or leaving the attempt dangling). Some robust LMS may detect an unclosed session and auto-terminate, but that’s not guaranteed or standard.

In summary, the LMS provides the infrastructure and strict rules, whereas the SCO must use the API correctly and provide the content logic. Both sides together ensure tracking and data exchange works.

#### Communication Flow and Error Handling

**Normal Flow Example:** Suppose a learner launches a SCO that teaches a lesson and includes a quiz: 1. LMS launches SCO in new window, with API ready. 2. SCO code finds API and calls Initialize: - If LMS returns "true", it sets an internal state "running". - SCO might then do: `let status = GetValue("cmi.completion_status")`. LMS returns "not attempted" (initial value if first attempt). - SCO then maybe sets `SetValue("cmi.completion_status", "incomplete")` immediately to mark that the attempt is now in progress (optional, some do it). 3. Learner goes through content. Partway, SCO sets `cmi.location` to "page5" for bookmark. 4. Learner completes an embedded quiz: - SCO calculates score 85%. It calls `SetValue("cmi.score.raw", "85")`, `SetValue("cmi.score.max","100")`, `SetValue("cmi.score.min","0")`. - SCO decides 85% \>= passing (say passing is 80), so sets `SetValue("cmi.success_status","passed")`. - SCO also sets `SetValue("cmi.completion_status","completed")` now because the quiz is done. - SCO might fill out an interaction record for each question via `cmi.interactions.n.*` calls (optional). 5. Learner clicks an "Exit" button in the content: - The SCO could set `adl.nav.request` to "continue" if it knows there’s a next SCO and wants LMS to launch it automatically[\[58\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Navigation%20controls%20are%20user%20interface,Some%20Rights%20Reserved)[\[59\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=SCORM%20requires%20that%20an%20LMS,that%20trigger%20Continue%2C%20Previous%2C%20and). If not, it might just set nothing or "exit". - The SCO calls `Terminate("")`. LMS persists all the data. - Terminate returns "true". The SCO can now safely close itself (maybe it calls `window.close()` or signals the user to close). 6. LMS receives the nav request "continue", looks at the course structure, and launches the next SCO if available.

**Error Handling:** Consider some error scenarios: - If the SCO calls `GetValue("cmi.foo")` for a non-existent element, the LMS returns an empty string and sets last error 401 (element not found). If the SCO blindly used that value, it might be an empty string. A compliant SCO should check `if(GetLastError() !== "0")` then handle. - If the SCO forgets to call Initialize and tries `SetValue("cmi.score.raw","85")`, the LMS will likely return "false". The error code would be 132 (or 403 in SCORM 1.2, but in 2004, likely 301 or 132 which is "not initialized"). The SCO should detect the "false" and perhaps attempt to call Initialize at that point (though ideally it should have done it first). - If the SCO calls Initialize twice accidentally, second call returns "false", error 103 (Already Initialized)[\[44\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=shall%20remain%20unchanged%20%28%E2%80%9CNot%20Initialized%E2%80%9D%29,%E2%80%9C%E2%80%9D%29%20%29%20more)[\[45\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=The%20Already%20Initialized%20error%20condition,shall%20be%20used%20when%20the). The SCO should not do that, and if it does, should safely ignore the second attempt. - If Terminate is called without Init, error 112 (Termination Before Initialization) occurs[\[56\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=SCO,when%20the%20SCO%20tries%20to)[\[57\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=The%20Termination%20Before%20Initialization%20error,The%20API%20Instance). That indicates a logic bug in the SCO (shouldn’t happen in correct sequencing). - If network disconnects or LMS crashes during a session, the SCO’s API calls might fail or never return. This is outside SCORM spec to handle, but robust content might implement a timeout and alert the learner that connection is lost.

**LMS-side error examples:** - The LMS should handle malformatted data. If SCO does `SetValue("cmi.score.raw","eighty five")` (non-numeric), LMS should return "false" with error 406 (data type mismatch). The SCO should then correct the value (which underscores the importance of data validation in content). - If SCO tries to create an 1000th interaction but LMS only supports 500, it returns error (typically 402 or 405 range). - After Terminate, if the SCO still calls SetValue (perhaps due to a scripting error where code continued), LMS must reject it with error 113 (Termination after termination)[\[42\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=3,The%20API%20Instance)[\[43\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=The%20Termination%20After%20Termination%20error,The%20API%20Instance).

In general, following the required API call order (Init once, then any Get/Set, optional Commit, then Terminate once) and handling return statuses will ensure smooth operation.

##### RTE Compliance Checklist (Run-Time & API Use)

- **API Initialization & Termination:** Each SCO calls `Initialize("")` when launched and `Terminate("")` when the learner finishes or leaves the SCO[\[41\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=A%20SCO%20is%20required%20to,the%20nature%20of%20the%20content). No SCO calls functions before initializing or fails to terminate. The SCO does not call Initialize more than once per launch, nor Terminate more than once[\[44\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=shall%20remain%20unchanged%20%28%E2%80%9CNot%20Initialized%E2%80%9D%29,%E2%80%9C%E2%80%9D%29%20%29%20more)[\[43\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=The%20Termination%20After%20Termination%20error,The%20API%20Instance).

- **Data Model Usage:** The SCO only uses SCORM-defined data model elements (e.g., `cmi.*` or `adl.nav.*`). All mandatory SCORM elements (like completion_status, success_status, score, etc. as applicable) are utilized properly. The SCO sets completion and success status appropriately by session end (or relies on LMS defaults if designed so, but best to set explicitly). If the SCO requires suspend/resume, it uses `cmi.exit = "suspend"` and populates `cmi.suspend_data` with needed state.

- **Data Format Compliance:** All SetValue calls use correct value formats and within allowed size:

- Scores are numeric and within min/max if those are set.

- status values use the exact vocabulary terms ("completed", "incomplete", "passed", "failed", etc.).

- Times are formatted according to SCORM rules (and session_time is provided).

- Text fields do not exceed length limits (e.g., interactions responses, suspend_data).

- No use of deprecated fields (like SCORM 1.2 `cmi.core.lesson_status` – in 2004 it’s `cmi.completion_status` + `cmi.success_status`).

- **Error Handling:** The SCO properly checks for error returns. At minimum, it handles a failed Initialize (perhaps attempts to find the API again or reports an error to user) and does not proceed if initialization failed. It also handles "false" returns from SetValue/Commit by at least logging or attempting corrective action. The SCO does not ignore the return values of API calls.

- **API Search Robustness:** The SCO’s method of locating the API can find it in various situations (pop-up window vs frameset, etc.). Use a standard search algorithm (commonly provided by SCORM wrappers). This ensures the SCO will work in different LMS launch scenarios (some embed content in an iframe, some in a new window).

- **LMS API Conformance:** The LMS implements all required API methods and error conditions as per SCORM 2004. For LMS developers: the API should handle sequence of calls, maintain internal state machine for initialization, and manage a data structure for the data model. The LMS must enforce read-only vs write properly (returning errors like 404)[\[50\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=the%20SCO%20requests%20the%20value,Example) and set initial values according to the spec or manifest. It should also support persistent data across sessions (for suspend/resume).

- **Data Persistence:** Confirm that data set by the SCO is actually stored and retrieved on re-entry. E.g., test a suspend scenario: suspend a SCO, relaunch it, and verify that bookmark or other data was restored correctly. This ensures LMS is properly saving runtime data (and not just in memory).

- **No Extra API Calls:** The SCO does not try to call non-existent or out-of-scope functions (like LMS-specific extensions) unless those are part of an agreed extension with the LMS. For instance, SCORM 2004 doesn’t have an API function to directly trigger navigation (that’s done via data model as `adl.nav.request`). So a SCO shouldn’t attempt something like `LMSNext()` (a non-standard call in some proprietary implementations).

- **Timing and Sequence:** The SCO allows the user to complete interactions before calling Terminate (i.e., it doesn’t auto-terminate in the middle of the session unexpectedly). Conversely, it does not leave the session hanging without termination if the user has finished the SCO or navigates away. If using pop-up windows, ensure the Terminate can still be called even if the user closes the window (e.g., prompt user or tie into window unload events).

- **Test with SCORM 2004 Test Suite:** Use ADL’s SCORM 2004 4th Ed conformance test suite or a known SCORM-conformant LMS in debug mode to run the SCO. Verify that no SCORM errors are reported. Specifically, all interactions from SCO are recorded, and the final status/score is as expected in the LMS’s tracking. The test suite can also simulate erroneous conditions to ensure the SCO and LMS handle them gracefully.

By satisfying these conditions, content developers ensure their SCOs reliably communicate results and status, and LMS developers ensure that they correctly support SCORM content. This mutual adherence is essential for interoperability: any SCORM 2004 SCO should function the same way across different LMSs in terms of launching, tracking, and completion behavior[\[41\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=A%20SCO%20is%20required%20to,the%20nature%20of%20the%20content)[\[60\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20Any%20LMS%20that%20supports,SCO%20in%20the%20same%20way).

### Sequencing and Navigation (SN)

SCORM 2004’s Sequencing and Navigation specification defines **how the learner can navigate through the activities** (as defined in the content organization) and how the LMS decides which content to deliver next based on the defined rules. It is based on the IMS Simple Sequencing (SS) standard, which SCORM uses to ensure that any compliant LMS will sequence and deliver content in a consistent manner according to the author’s intent[\[61\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=1,the%20intended%20behavior%20of%20an)[\[62\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=authored%20learning%20experience%20such%20that,terms%20of%20an%20activity%20tree). In practice, sequencing in SCORM means you can specify prerequisites, branching rules, attempt limits, and completion requirements between the SCOs/activities in your course *without hard-coding it into the SCOs*. The LMS, guided by the sequencing rules in the manifest, will handle the logic of what the “Next” button does, whether a SCO is allowed to be accessed, and when the course is finished.

Key concepts in SN include the **Activity Tree**, **Sequencing Definitions** (control modes, sequencing rules, limit conditions, etc.), **Navigation Requests** (Continue, Previous, Choice, etc.), and **Rollup Behaviors** for aggregating results up the tree.

#### Activity Trees and Sequencing Model Overview

An **Activity Tree** is the runtime representation of the course structure for a given learner. It mirrors the content organization from the manifest: each node in the tree is an activity (cluster or leaf) with the same hierarchy as the `` defined. The LMS creates an individual activity tree for each learner’s attempt through the course. This tree tracks each activity’s **tracking status** (like whether it’s completed, satisfied, how many attempts have been made, etc.)[\[63\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=The%20SCORM%20SN%20Model%20defines,Some%20Rights%20Reserved)[\[64\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=activity%20tree%2C%20CAM,a%20conceptual%20structure%20of%20learning). The root of the tree is typically the course itself (top-level activity), intermediate levels might be modules/lessons (clusters), and leaves are SCOs or asset launches.

Sequencing rules are applied to this activity tree at runtime. The SCORM SN specification defines an **Overall Sequencing Process** which the LMS runs whenever a navigation event occurs (like the user clicks "next", or a SCO signals it’s done and auto-continues)[\[65\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=ignore%20the%20Continue%20navigation%20event,translate%20the%20navigation%20event%20into)[\[66\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=2,translate%20the%20navigation%20event%20into). This process evaluates the defined rules and the state of the tree to decide which activity to deliver next (or whether to end the sequencing).

Important aspects of the activity tree and sequencing: - **Current Activity:** At any time during delivery, one activity is the *current* one being delivered (i.e., the SCO the learner is viewing belongs to this activity). The state of that activity (attempt in progress, etc.) influences what can happen next. - **Tracking Data:** Each activity in the tree has associated tracking data (some tracked by the LMS, some by SCO): - Activity Completion Status (complete/incomplete). - Activity Success Status (satisfied/not satisfied). - Progress Measure or Score (if used). - Attempt count (how many times the learner has attempted this activity). - For clusters, aggregation of children’s statuses (rollup results). - **Activity Transitions:** Sequencing defines how we move from one activity to another (e.g., once one SCO is finished, which one becomes current?).

The sequencing definitions in the manifest (under `` for each relevant ``) specify the rules and behaviors for that activity.

#### Sequencing Definitions: Rules, Control Modes, and Constraints

**Sequencing Control Modes:** These are high-level flags that determine the basic navigation behaviors permitted for the children of a cluster (or the overall course): - **Choice:** If choice mode is enabled (`true`), the learner is allowed to navigate (out-of-sequence) to any other activity (typically via a table of contents or menu) as long as that target is not disabled by other rules. If choice is `false` for a given cluster, the learner cannot freely jump between its children – they must follow the imposed sequence. (Often, courses set choice = true at the root so learners can pick modules in any order, or false to lock them into a path.) - **Flow:** If flow mode is enabled, the LMS will automatically sequence from one activity to the next (in the defined order) when the learner indicates a Continue or Previous. Flow basically allows linear traversal (like a next button goes to next item without showing menu). If flow is false, then the LMS will not automatically move to the next activity upon completion; the learner would have to use a menu or the LMS UI to pick where to go (or the content could issue navigation requests). - **Forward Only (Control Forward Only):** This flag (a sub-option under choice) if set, prevents the learner from going backwards once they’ve progressed (it disallows “Previous” or choosing a prior item via TOC after moving forward). This is used when content should be strictly linear without backtracking.

Control modes are set in the manifest under `` for an activity. For example, `` on the root might mean the learner can use both the LMS next/prev and also skip via menu freely (somewhat redundant combination, but typical defaults are choice=true, flow=true at root).

**Constrained Choice Considerations:** SCORM allows additional constraints on choice navigation using ``. For instance, one option is `preventCurrentActiveChildren` which if true means a learner cannot jump into an activity that has an active (not completed) descendant, etc. These fine-tune how choice navigation works especially in complex trees (ensuring they don’t break out of an ongoing sequence).

**Sequencing Rules:** These are the core "if-then" rules that govern dynamic sequencing decisions. There are three categories of sequencing rules: - **Precondition Rules:** Evaluated **before** an activity is attempted (or when considering if it can be delivered). These can affect whether an activity is allowed to be delivered or selected. The conditions typically check things like whether another activity is completed, satisfied, attempted, etc., and the actions can be: - *skip*: skip this activity in a flow sequence (treat it as if it’s not there, go to next one)[\[67\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Process,request%20to%20target%20this%20activity)[\[68\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=%E2%80%A2%20If%20satisfied%20Then%20skip%3A,allow%20a%20Choice%20sequencing%20request). - *disabled*: prevent the activity from being available for any navigation (e.g., grayed out in menu)[\[67\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Process,request%20to%20target%20this%20activity)[\[69\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=the%20activity%20is%20satisfied,allow%20a%20Choice%20sequencing%20request). - *hidden from choice*: the activity will not be shown as a choice option to the learner (though it could still be reached via flow)[\[67\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Process,request%20to%20target%20this%20activity)[\[69\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=the%20activity%20is%20satisfied,allow%20a%20Choice%20sequencing%20request). - *stop forward traversal*: used in choice sequencing to prevent moving past this point (in flow context, SCORM 2004 actually ignores this for flow nav)[\[70\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=%E2%80%A2%20If%20satisfied%20Then%20skip%3A,Some%20Rights%20Reserved)[\[71\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=attempted,definition%20of%20the%20sequencing%20rule).

Precondition rules are often used to implement **prerequisites**. For example, “If *Module 1* is not completed then disable *Module 2*” would be a precondition on Module 2 (so that until Module 1 complete, Module 2 cannot be started). Or “If this test is passed then skip the remedial lesson” could be a rule on a remedial lesson to skip it if the test is already passed.

- **Postcondition Rules:** Evaluated **after an activity ends** (after a SCO is completed/exited), controlling what happens next. These rules typically trigger navigation events. Actions include:
- *Exit Parent*: End the current activity and do not automatically continue within the current cluster – instead, jump out to the parent activity (often used to say “once this activity done, go back up”).
- *Exit All*: End the whole course (basically finish all – often used on a final assessment like “if failed then exit all” to kick them out).
- *Retry*: Immediately retry the same activity (start a new attempt on it).
- *Retry All*: Go back to the beginning of the course (or a module) and start over.
- *Continue*: Equivalent to issuing a Continue navigation request (go to next in sequence)[\[72\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Post%20Condition%20Actions%203%20Rule,Return%20a%20Retry%20sequencing%20request)[\[73\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=%E2%80%A2%20Retry%20%E2%80%93%20Return%20a,Vocabulary%20Ignore).
- *Previous*: Issue a Previous request (go to previous in sequence)[\[74\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=request%20and%20return%20a%20Start,Vocabulary%20Ignore).

Postconditions are powerful for automating behaviors. For example, a common pattern: on a quiz SCO, “If passed then Exit Parent (i.e., leave the quiz module, perhaps to skip any remediation), If failed then Retry (i.e., have them retake the quiz)”. Or at end of a module: “If completed then Continue” (so it auto-continues to next module), etc.

- **Exit Action Rules:** A very narrow category, essentially one action: *Exit* – which means “terminate the attempt on this activity immediately” (like a forced exit)[\[75\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Table%203,Forward%20Traversal%20Rule%20Action%20when). This is rarely used on its own except for specific nested sequencing behaviors, but conceptually it can be used to say if some condition mid-activity triggers an exit.

The rules consist of a condition (which can include multiple conditions combined with AND/OR, and each condition can be normal or negated) and an action if the condition set is true[\[76\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=them,condition%20set%20results)[\[77\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=,condition%20set). Conditions can check things like: this activity’s status (attempted, completed, satisfied), a child’s status, number of attempts, score, etc. The SCORM SN specification provides a full list (e.g., **if** \[Not Satisfied\] **then** do something, **if** \[Attempt Limit Exceeded\] **then** do something, etc.). The rules are evaluated in a particular order depending on type (e.g., all preconditions are checked during navigation, postconditions right after an attempt ends, etc.). If multiple rules apply, SCORM defines the sequence (for example, among preconditions: if any skip triggers, it might override others, etc.).

**Limit Conditions:** These are simple limits attached to an activity to restrict availability: - **Attempt Limit:** The number of allowed attempts on an activity. If an activity (usually a SCO or an assessment) has a `attemptLimit="N"` in its sequencing, then once the learner has attempted it N times, it will no longer be available (the LMS will consider it "completed" or simply not let it launch again). SCORM 2004 *requires* LMS support for the attempt limit condition[\[78\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=4,Evaluating%20Precondition%20Sequencing%20Rules)[\[79\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=the%20Max%20Attempt%20Limit%20limit,action). For instance, if a test should only be taken twice, set attemptLimit="2". The LMS will track attempts and after 2, the item becomes disabled (the spec says when the limit is reached, the activity is *terminated* and considered completed for sequencing purposes). - **Duration Limit:** SCORM also defines possible time limit per attempt (like “must complete this SCO in 10 minutes”). This is the **attempt absolute duration limit** in IMS SS. However, SCORM 2004 does **not require** LMSs to enforce time limits (and most don’t at run-time)[\[80\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=4,based%20limit%20conditions). Instead, SCORM leaves it optional for LMS to implement time-outs. The content could internally enforce time if needed. So you can set a time limit in manifest, but it might be advisory unless the SCO itself checks `cmi.session_time` or the LMS has custom logic. - Other limits like “activity absolute duration limit” (time across all attempts) or “attempt experienced duration limit” exist in theory, but again not mandated.

When a limit condition is violated (e.g., learner tries to launch but max attempts reached), the LMS will mark the activity as not available and typically trigger a sequencing event (like if you hit Continue on a finished item with no attempts left, it should skip it).

**Objective and Measured Rollup:** (This touches both sequencing rules and rollup behaviors.) Each activity can be associated with an **objective**, which tracks whether the activity is “satisfied” or not (i.e., learning objective mastery). By default, each activity has a **primary objective**, for leaf nodes often tied to the SCO’s success status. Activities can also have shared or global objectives. Sequencing rules can consider objective status as conditions (like “if not satisfied then ...”). Objectives can have a numeric measure (like a score).

**Rollup Rules:** Rollup is how child activities’ statuses roll up into the parent activity’s status. For example, a module with several SCOs: when do we consider the module completed or passed? SCORM has a default rollup behavior and allows customization: - For **completion rollup** (did the parent get completed?): By default, SCORM says: - If *all* children are completed, then the cluster is completed. - If all children that have a known completion status are either completed or incomplete and at least one is incomplete, then cluster is incomplete[\[81\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=SCORM%202004%204th%20EditionSequencing%20and,equal%20to%20False%2C%20then%20the)[\[82\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=%E2%80%A2%20If%20all%20completed%2C%20Then,Measure%20have%20no%20effect%20on). - (If some children are still not attempted, the cluster remains incomplete/unknown until they are attempted.) - For **satisfaction rollup** (did the parent’s objective get satisfied/passed?): Default: - If *all* children are satisfied, then the parent is satisfied. - If all children with known status are evaluated and one or more are not satisfied, then parent is not satisfied[\[83\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Figure%204,satisfied%20rule%20is%20evaluated%20first)[\[84\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=actions%20satisfied%20or%20not%20satisfied%2C,satisfied%20rule%20is%20evaluated%20first). - (If some children have unknown objective status, parent remains unknown.)

Thus by default, a parent requires all children to be done (and passed) to itself be considered done (and passed). These defaults can be overridden by explicit rollup rules on the parent. For instance, you might have a module where the learner only needs to complete *one* of two lessons to satisfy the module – you could write a rollup rule: “if any child satisfied then satisfied” for objective rollup, and similarly for completion.

Rollup rules in manifest allow conditions like “Percent of children completed \> X then complete parent” or “Any child satisfied then satisfied” etc., or you can disable rollup entirely for certain objectives. SCORM includes a full set of rollup rule definitions, but in many cases you can rely on defaults or simple configs: - Mark an activity’s *progress* or *objective* rollup as false if you don’t want it to count children (then you’d manually handle via sequencing or content). - Use the `completedByMeasure` or `objectiveMeasureWeight` to have numeric thresholds control rollup (like if the average score of children is X). - SCORM 2004 4th Ed refinements ensure consistent rollup ordering (first apply any defined rules, if none, use default rules)[\[83\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Figure%204,satisfied%20rule%20is%20evaluated%20first)[\[84\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=actions%20satisfied%20or%20not%20satisfied%2C,satisfied%20rule%20is%20evaluated%20first).

**Randomization and Selection:** These controls allow for dynamic delivery of a subset or shuffled order of child activities: - **Randomization Controls:** You can indicate that the order of children under a given cluster should be randomized each attempt (or once, etc.)[\[85\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Attributes%3A%20%E2%80%A2%20randomizationTiming%20,the%20number%20of%20child%20activities)[\[86\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=activity%20,This%20attribute%20indicates%20when%20the). Attributes like `reorderChildren="true"` and `randomizationTiming="once"` or `"onEachNewAttempt"` control when to shuffle the order. - **Selection Controls:** You can specify that only a certain number of children should be selected from the pool under a cluster (like drawing 5 questions out of a bank of 10) using `selectCount` and related attributes[\[85\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Attributes%3A%20%E2%80%A2%20randomizationTiming%20,the%20number%20of%20child%20activities)[\[87\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=o%20onEachNewAttempt%20%E2%80%A2%20selectCount%20,XML%20Data%20Type%3A%20xs%3Aboolean). The timing (once or each attempt) determines when the selection occurs.

The LMS uses these settings to perform the *Select and Randomize Processes* either when the activity is first attempted or at the start of each new attempt, depending on timing[\[88\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=considered%20during%20any%20sequencing%20behavior,during%20rollup%20and%20the%20various)[\[89\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=starting%20the%20sequencing%20session,during%20rollup%20and%20the%20various). For example, if a test has 10 questions and you set selectCount="5" and selectionTiming="onEachNewAttempt", the LMS will randomly pick 5 of the questions every time the learner starts that test fresh, providing variety. If randomizationTiming is "never", the order is as authored in manifest.

**Delivery Controls (Attempt Completion Controls):** As defined earlier (from manifest ``): - **Tracked** (true/false): If false, the activity is not tracked for completion or satisfaction in rollup (essentially the LMS treats it as untracked – perhaps an optional content that doesn’t count)[\[90\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20tracked%20,activity%2Fattempt%20progress%20information%20for%20the)[\[91\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=attempt%20should%20be%20recorded%20,5). - **completionSetByContent** (true/false): If true, the SCO is expected to set its own completion status. If false, the LMS may auto-complete the activity when the SCO’s attempt ends (e.g., if not set by content, the LMS could mark it completed by virtue of the attempt being over)[\[92\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=for%20its%20parent%20activity%20,XML%20Data%20Type%3A%20xs%3Aboolean). Many platforms leave this false so that if the SCO forgets to set completion, they can consider an attempt as completion. However, SCORM’s logic if false is not to automatically complete always, it often stays incomplete if not set, which is why content setting it is safest. - **objectiveSetByContent** (true/false): If true, the SCO will explicitly set success status. If false, the LMS will determine success of the activity after SCO termination, usually by comparing score to mastery (if a mastery score is defined)[\[93\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=indicates%20that%20the%20attempt%20completion,Elements%3A%20%E2%80%A2%20None)[\[94\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%28true%20or%20false%29%20,XML%20Data%20Type%3A%20xs%3Aboolean). Default false works if you have a mastery score; but if none, leaving it false and SCO not setting success will just leave it unknown or satisfied by other rules. Best practice: if your SCO sets passed/failed, set objectiveSetByContent to true to avoid any conflict.

Setting these correctly ensures there is no ambiguity in who is responsible for marking completion and success. For example, for a passive SCO that doesn’t report pass/fail, you might leave objectiveSetByContent false and define a mastery score – the LMS will then decide based on score. If the SCO does its own evaluation and calls passed/failed, mark it true.

#### Navigation Models and Learner Navigation

**Navigation Events and Requests:** SCORM distinguishes between **navigation events** (triggered by the learner via UI or by the system) and **navigation requests** (the abstract requests the LMS processes). The typical navigation events the learner can trigger (usually by clicking buttons in the LMS interface or content) are: - **Continue**: Move to the next activity in the defined sequence order (often bound to a “Next” button in the LMS UI). - **Previous**: Move to the previous activity in sequence (bound to a “Back” or “Previous” button). - **Choice (Choose Activity)**: Jump to a specific activity the learner selected (from a menu or table of contents). This event carries a target activity ID. - **Exit**: Exit the current activity/course (stop sequencing but remain enrolled, often returns to LMS course home). - **Exit All**: Exit the entire course package (if the course launched in a new window, this would typically close it and end all tracking). - **Suspend All**: Pause all and suspend the session (not always an explicit button, but some LMS treat closing a course as suspend all). - **Resume All**: (Usually automatic) If a learner returns to a suspended course, the LMS might use Resume All to go back where they left off. - **Start**: Begin at the start of the course (this happens implicitly on first launch). - **Retry/Restart**: Some define "Retry" event, which effectively is like starting over an activity or course after completion.

The LMS must translate these events into the appropriate **sequencing requests** and run the sequencing process[\[65\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=ignore%20the%20Continue%20navigation%20event,translate%20the%20navigation%20event%20into)[\[66\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=2,translate%20the%20navigation%20event%20into). For example: - A **Continue** event while a SCO is active means: first, end the attempt on the SCO (Exit Termination is processed), then run the **Overall Sequencing Process** with a Continue request, which tells the LMS to find the next available activity in the tree (usually the next sibling of the SCO, or if none, go up). If at the end of course, a Continue has no next and is ignored[\[95\]\[95\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=For%20example%2C%20if%20the%20learner,translate%20the%20navigation%20event%20into). - A **Previous** event similarly ends current SCO and triggers the sequencing process with a Previous request, meaning find the previous eligible activity (usually the prior sibling, or if none, maybe nothing happens)[\[96\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Start%20If%20the%20Current%20Activity,is%20True%2C%20issue%20an%20Exit)[\[97\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Continue%20If%20Activity%20is%20Active,Issue%20a%20Previous%20sequencing%20request). - A **Choice** event triggers a Choice sequencing request with a target=some activity. The sequencing algorithm will attempt to navigate directly to that target, if allowed (it will check the sequencing rules like hidden-from-choice or disabled flags on that target and possibly its ancestors). If it’s not allowed, LMS may ignore or throw a message.

The SCORM SN specification ensures all LMSs handle these the same way. For instance, if a Continue would result in nothing (like we are at last activity), the LMS should not provide a Continue button at that time[\[58\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Navigation%20controls%20are%20user%20interface,Some%20Rights%20Reserved)[\[98\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=indicate%20the%20desire%20to%20navigate,In%20addition). SCORM requires LMS UI to be smart about enabling/disabling navigation controls based on the current state: do not show a Next if there is none (or if next is disabled by a rule), etc. This avoids confusion[\[59\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=SCORM%20requires%20that%20an%20LMS,that%20trigger%20Continue%2C%20Previous%2C%20and)[\[99\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Continue%2C%20Previous%2C%20and%20Choice%20navigation,events%20will%20result%20in%20a).

**LMS Navigation Controls vs Content Navigation:** The LMS typically provides UI controls (Next, Previous, Menu of topics). However, content itself can also offer navigation (like a “Next Module” button inside a SCO). SCORM 2004 addresses this by: - If content has its own nav UI and you want to use that instead of LMS’s, you can use the `` in the manifest to tell the LMS to hide its default nav UI for certain activities[\[100\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=SCORM%20also%20provides%20the%20means,5%3A%20The%20SCORM%C2%AE%20Navigation%20Model). Many authoring tools set this so that their custom buttons work without duplicate LMS buttons. - The content’s buttons then internally call SetValue(`adl.nav.request`, "continue"/"previous"/"exit"/etc.) to trigger nav on Terminate. E.g., a “Next” button in content might do: `SetValue("adl.nav.request","continue"); Terminate("");` – which effectively hands control to LMS to go to next. - The LMS must honor valid nav requests from content. If content said "exit", LMS will just exit the course (maybe close window). If "continue", LMS should go next as if user clicked next. If the request was invalid (like "continue" at end of course), the LMS will just end with nothing (the spec says such a request leads to no new activity – basically ignored safely).

**Overall Sequencing Algorithm:** In short: - When a navigation request (from UI or content) is issued, the LMS performs: 1. **End Attempt Process** on current activity (if one is active and the nav requires leaving it): this might involve marking it completed if not done, applying exit sequencing rules (exit actions). 2. **Determine Target:** Depending on the request (continue, previous, choice target, etc.), identify the target activity for delivery. 3. **Sequencing Rules Check:** Apply any relevant sequencing rules (preconditions on the target and maybe others) to see if the target is allowed. If a precondition rule says "skip" the target, then the sequencing engine will actually skip it and move to the next candidate in line (for flow nav). 4. **Overall Sequencing Process:** This might involve searching down the tree (for "start" or "resume", LMS finds the first valid deliverable leaf under the root or resume point). 5. **Deliver Activity:** Once a target activity is identified as the next to deliver, if it is a **leaf activity** (with a resource), the LMS launches the associated SCO/asset. If it is a cluster (say the user jumped to a module that wasn’t yet expanded), the LMS will need to enter that cluster and find the appropriate descendant to launch (usually the first available leaf under it). 6. If no activity is available (e.g., the course is complete), a Continue or Start might result in a no-op or course termination.

**Example Navigation Logic:** Suppose we have a linear course with 3 SCOs (A, B, C). Continue and Previous move along them. If the learner is on A and clicks Next (Continue), LMS will attempt to deliver B next. If B had a precondition "if A not completed then disabled", then if A was indeed not completed, that rule would prevent B from being available – the sequencing process might then skip B and go to C if the rule for B triggered "skip" or just not allow Continue if B is disabled (depending on how rules are authored). If properly authored, one might say "if A not completed, then prevent B from even being accessible", so in that case, after finishing A incomplete, Continue might end the course because B is disabled and C presumably also locked behind B.

**End-of-Course:** When the sequencing logic determines no further activities, the course is done. The LMS might show a completion message or simply not navigate further. SCORM doesn’t specify the UI here, but often the LMS will mark the course complete if the root activity is satisfied/completed.

#### Best Practices for Sequencing Design

- **Keep Sequencing as Simple as Possible:** While SCORM allows very complex rule sets, simpler rules are easier to maintain and less error-prone. Use straightforward structures (like linear flow or clearly separated modules) and minimal necessary rules. Overly complex sequencing can confuse both authors and learners.

- **Typical Sequencing Patterns:** Common patterns include:

- **Linear sequence:** Use flow = true to auto-continue. Possibly no rules at all – default behavior will just go in document order. This is simplest.

- **Locked sequence until completion:** Set `controlMode.choice = false` at root (so no free jumping), and maybe forwardOnly = true if you want to forbid revisiting past content. This ensures learner must use Next in order.

- **Prerequisite gating:** Instead of older prerequisite element, implement as a precondition rule: On the item that should be gated (locked), add rule "if \[prerequisite activity\] not completed then disable (or hidden from choice)". This ensures that until the earlier activity is done, the later one cannot be launched[\[67\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Process,request%20to%20target%20this%20activity)[\[68\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=%E2%80%A2%20If%20satisfied%20Then%20skip%3A,allow%20a%20Choice%20sequencing%20request).

- **Mastery-based branching:** For example, if a pre-test passed then skip the content module and jump to post-test. Implement by a postcondition on the pre-test activity: "if passed then skip content module" – actually skip is a precondition action, so more likely one would set a *precondition* on the content module: "if pre-test satisfied then skip this content". Alternatively, on pre-test postcondition: "if passed then *Exit All* (or Continue past some things)", depending on design.

- **Retaking tests:** Use a postcondition on a failed test: "if failed then Retry" to have them automatically get another attempt at the same test[\[72\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Post%20Condition%20Actions%203%20Rule,Return%20a%20Retry%20sequencing%20request)[\[101\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=evaluates%20to%20True,and%20return%20a%20Start%20sequencing). Be sure to set attemptLimit accordingly if you want only certain number of retries.

- **Limited attempts on SCO:** If you only want a SCO launched a fixed number of times, set ``. The LMS will handle disabling it after N attempts[\[78\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=4,Evaluating%20Precondition%20Sequencing%20Rules)[\[79\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=the%20Max%20Attempt%20Limit%20limit,action). Optionally, you can add a postcondition "if attemptLimitExceeded then (e.g.) Exit or Continue" to direct what happens after failing final attempt.

- **Optional content (not affecting rollup):** If you have optional slides or enrichment that shouldn’t count towards completion, mark them `tracked="false"` in deliveryControls[\[90\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20tracked%20,activity%2Fattempt%20progress%20information%20for%20the)[\[91\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=attempt%20should%20be%20recorded%20,5). They won’t affect parent completion and might not even need completion status set by content. Alternatively, put them in a separate organization or a side branch the learner can visit (with choice nav) that doesn’t tie into the main sequence.

- **Testing Sequencing:** Always test sequencing logic in a SCORM sandbox. Complex conditions can yield unexpected results. Use SCORM debugging (if LMS provides logs) to see rule evaluations. For instance, a rule "if completed then continue" on a SCO might inadvertently auto-continue as soon as it’s marked completed, which could skip feedback screens if the SCO sets completed too early. Be mindful of when status gets set versus when the SCO actually calls Terminate. Often, it’s safer to let the learner initiate continue rather than automatic, unless you clearly want auto-advancement.

- **Avoid Conflicting Rules:** For example, setting both a precondition on an activity and a postcondition on a sibling that both try to control flow might conflict or be redundant. Also, be careful that skip rules don’t inadvertently skip content you actually need delivered. The Stop Forward Traversal rule is rarely needed; using disable/hidden usually suffices for gating.

- **Use Global Objectives for Shared Outcomes:** If you have multiple SCOs that contribute to the same goal (like a pre-test and post-test both affecting a single course mastery), consider using the SCORM global objective mapping. Define an objective with an ID (in ``) in the manifest for the course, map both SCOs’ primary objectives to that global one (using ``). This way, if the pre-test passes, the global objective becomes satisfied and the post-test activity can have a precondition like "if objective satisfied then skip" (skipping the post-test altogether) or count the course as passed. This is advanced, but SCORM supports it to avoid having to put all logic in one SCO.

- **Delivery and UI Considerations:** If using content-provided navigation, ensure to set `hideLMSUI` accordingly for each activity that has its own nav UI to avoid double navigation controls[\[100\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=SCORM%20also%20provides%20the%20means,5%3A%20The%20SCORM%C2%AE%20Navigation%20Model)[\[102\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=to%20identify%20that%20the%20content,potentially%20confusing%20user%20interface%20controls). If the LMS UI is used, ensure your choice of control modes makes sense with it (e.g., if you disable choice, the LMS menu might not allow clicks on certain items).

- **Sequencing vs Content Responsibility:** Decide which logic to implement via sequencing vs in content. For example, you could script a SCO to not let the learner progress until they’ve clicked all sections (content-side enforcement), or you could simply break content into separate SCOs and use sequencing preconditions to ensure one SCO (section) must be completed before the next can launch. Generally, if it’s a matter of content completion, SCORM sequencing is preferable since it keeps the logic external and standardized. But if something is very granular (within a single SCO’s internal flow), handle it inside the SCO.

- **Edge Cases:** Be aware how the course should behave if a learner fails and maxes out attempts – sequence what happens (maybe direct them to a remedial module or end course with a failure message). Also consider “what if the learner uses the menu out of order?” – if choice is true, they might circumvent your intended order unless you add rules to prevent it.

#### SN Compliance Checklist (Sequencing & Navigation)

- **Manifest Sequencing Definition:** Each activity (``) that requires special sequencing has an `` entry with the appropriate sub-elements (controlMode, sequencingRules, limitConditions, etc.). The sequencing XML is correctly placed (either directly under each item or using `` and referencing it). Validate that the sequencing XML passes schema (common errors: wrong namespace usage, e.g., using `adlcp:` instead of `imsss:` for some elements, or typos in attribute values).

- **Default vs Custom Sequencing:** If no custom sequencing is needed, SCORM’s default will allow free choice and no restrictions. If that’s acceptable, ensure at least that doesn’t conflict with your design. If custom rules are needed (prerequisites, etc.), ensure they are explicitly defined. Do not assume the LMS will enforce an order without rules if choice is enabled by default.

- **Control Mode Settings:** Verify the `choice` and `flow` settings at relevant levels:

- If the course should be strictly sequential with next/back only, `flow=true`, `choice=false` at the root (or relevant cluster).

- If menu navigation is allowed, `choice=true`. If only forward progression and no going back, `forwardOnly=true`.

- These settings are consistent with the desired learner experience and UI provided.

- **Sequencing Rule Logic:** Check each sequencing rule:

- Clearly identify the target of the rule (the activity on which it is defined).

- Double-check conditions refer to the correct activities or status. (For example, a rule on Activity B might check if Activity A is satisfied; ensure Activity A’s identifier is correctly referenced if using global objectives or rollup, otherwise use simpler conditions like "if previous sibling not completed".)

- Ensure no contradictory rules (e.g., a precondition says skip and another says disable on the same condition – only one will really apply).

- Ensure the timing of rules matches your intent (preconditions block or hide before launch, postconditions fire after completion).

- **Test scenarios**: For each rule, envision a scenario where its condition is true and ensure the action does what you want. For instance, "if attempted then disable" on an activity – once the learner has attempted it, it becomes disabled (not launchable again). Is that intended (perhaps to prevent re-entry)? If yes, okay. If not, adjust attempt limits or rule.

- **Limit Conditions and Attempts:** If using `attemptLimit`, make sure the number is correct and consider user experience (e.g., if attemptLimit=1 on a SCO, once they finish it, the LMS won’t let them back in that SCO; usually combine with a postcondition to redirect them or show a message via an Exit All or such). Also ensure the LMS you use handles attempt limit (it should, as required) – you can test by attempting more than allowed times to see if it blocks further launch.

- **Rollup and Completion:** Verify parent activities properly roll up child statuses:

- If you left defaults, that means “complete when all children complete” and “satisfied when all children satisfied”. Is that okay? For many linear modules, yes.

- If you want a module to count as completed when at least one of its children is completed (e.g., an either/or path), then implement a rollup rule for that parent.

- If you have standalone optional content marked not tracked, ensure `tracked="false"` on those so they don’t block rollup (the LMS will ignore untracked in rollup).

- For course completion (root activity), decide what constitutes “course completed/passed”. Often, course (root) has no SCO itself, it’s just a cluster. The LMS will mark the course completed when all required leafs are done or via rollup rules. If, say, the course is considered passed if the final exam is passed, you might map that by using the final exam’s objective to set the course objective. Or you leave it to “all satisfied -\> course satisfied”. Just ensure it matches your success criteria. You can also have the last SCO explicitly call `adl.nav.request = "exitAll"` with `SetValue("cmi.exit","")` and Terminate, which will exit course; but the actual status for the course should ideally reflect aggregate performance.

- **Navigation UI Checks:** If you rely on the LMS provided navigation controls:

- Ensure the LMS indeed hides Next at end, etc. (If using a generic LMS, they usually do. If custom environment, follow SCORM rule to not show controls that would do nothing or break sequencing[\[58\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Navigation%20controls%20are%20user%20interface,Some%20Rights%20Reserved).)

- If you embed navigation in content, verify `` in manifest to hide LMS UI and test that your content’s Next/Back buttons correctly trigger the desired nav (via `adl.nav.request` calls).

- Make sure the content calls Terminate after setting `adl.nav.request` or the nav request won’t be processed (it only triggers at termination of the attempt).

- **Corner Cases in Navigation:** Try out branching in a test: e.g., if a learner tries to jump (Choice) to an activity that should be locked by a rule, does the LMS prevent it? It should either not show it or ignore the click. SCORM says hidden-from-choice means it shouldn’t show; disabled means show but not clickable. Different LMS UIs vary. Ideally, test on a SCORM Cloud or similar to see how your sequencing behaves.

- If using randomization, test that multiple launches give different orders or subsets as expected. Also ensure that random selection doesn’t conflict with completion logic (like if only 5 out of 10 questions delivered, the module might only consider those 5 for completion – which is fine, but ensure scoring accounts for that).

- **Documentation for Users:** Provide course navigation instructions to learners, especially if some modules only unlock after others. Sometimes sequencing makes a module unclickable until prerequisites are done; ensure the learner is informed why (either by graying out and showing a lock icon in the LMS, or via content messaging like "Complete Module 1 first"). This is more about design, but important for user experience.

- **Conformance Testing:** Use the ADL Sequencing Example test cases if possible. The SCORM Sample RTE Content ("Golf examples") includes various sequencing scenarios. If your sequencing is non-trivial, comparing its behavior in a known SCORM test bed can validate you did it right.

By fulfilling these checklist items, developers ensure that their SCORM 2004 4th Edition content enforces the intended learning paths and rules reliably on any compliant LMS, and that learners experience consistent behavior (no dead-ends or unexpected jumps)[\[103\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=and%20an%20authored%20sequencing%20strategy,for%20delivery%20will%20have%20an)[\[104\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=learning%20activities%20managed%20by%20the,how%20identified%20content%20objects%20are). Proper sequencing design can handle complex instructional strategies such as remediation loops, optional content, and adaptive paths, all controlled through manifest settings rather than custom code.

------------------------------------------------------------------------

**Conclusion:** Adhering to SCORM 2004 4th Edition across the Content Aggregation Model, Run-Time Environment, and Sequencing/Navigation aspects will yield e-learning modules that are highly interoperable and trackable. Course creators should focus on structuring content into reusable SCOs and packaging them correctly, leveraging metadata and profiles for consistency. When developing SCOs, following the API usage requirements and data model ensures any LMS can launch and track them[\[60\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20Any%20LMS%20that%20supports,SCO%20in%20the%20same%20way). Finally, applying sequencing rules thoughtfully allows you to enforce educational logic (prerequisites, branching, attempts) in a standardized way, leaving the heavy lifting to the LMS to execute those rules[\[61\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=1,the%20intended%20behavior%20of%20an)[\[63\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=The%20SCORM%20SN%20Model%20defines,Some%20Rights%20Reserved). By using the provided compliance checklists and best practices, both content developers and AI-based content generation tools can validate that the output meets SCORM 2004 4th Edition specifications, resulting in content that passes SCORM conformance tests and provides a smooth learning experience across platforms.

------------------------------------------------------------------------

[\[1\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=3,content%20package%20also%20provides%20a) [\[2\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=SCORM%20Content%20Packaging%20is%20a,for%20packaging%20assets%2C%20SCOs%20and) [\[3\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=2,In) [\[4\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=The%20asset%20is%20the%20basic,part%20of%20the%20learning%20experience) [\[5\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=2,the%20Institute%20for%20Electrical%20and) [\[6\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=learning%20resource%20that%20uses%20the,1%5D.%20Figure%202.1.2a%20below) [\[7\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=To%20improve%20reusability%2C%20a%20SCO,For) [\[8\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=SCOs%20are%20intended%20to%20be,requirements%20for%20an%20organization%20will) [\[9\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=A%20learning%20activity%20may%20be,A) [\[10\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=activities,be%20defined%20for%20activities%20and) [\[11\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=which%20may%20themselves%20consist%20of,used%20to%20perform%20the%20activity) [\[12\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=2,described%20with%20metadata%2C%20thereby%20enabling) [\[15\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Sequencing%20only%20applies%20to%20activities,sequencing%20behaviors%20to%20control%20the) [\[16\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Within%20SCORM%2C%20sequencing%20information%20is,This%20is) [\[17\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=2,Sometimes%20the) [\[18\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=XML%20Binding%20Representation%3A%20,Resource%201%20and%20only%201) [\[25\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=application%20profiles%2C%20of%20the%20IMS,for%20packaging%20assets%2C%20SCOs%20and) [\[26\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Section%203,Guidelines%20defines%20a%20collection%20of) [\[27\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Application%20Profiles%3A%20%E2%80%A2%20Resource%20Content,Profile%3A%20A%20content%20package%20for) [\[28\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20Resource%20Content%20Package%20Application,Profile%3A%20A%20content%20package%20for) [\[29\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=content%20structure,Profile%3A%20A%20content%20package%20for) [\[30\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Application%20Profiles%3A%20%E2%80%A2%20Resource%20Content,with%20no%20defined%20organization%20or) [\[31\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20Content%20Aggregation%20Content%20Package,Profile%3A%20A%20content%20package%20for) [\[32\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=4,146%204.5.4.%20Metadata%20Describing%20SCOs) [\[33\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=4,147%204.5.5.%20Metadata%20Describing%20Assets) [\[34\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Attributes%3A%20%E2%80%A2%20identifier%20,The%20identifier%20attribute%20is%20typically) [\[35\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=ADL%20Note%3A%20The%20IMS%20Global,sub%29manifests) [\[37\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=SCORM%20Requirements%3A%20The%20manifest%20element,Parent%20elements%20have%20no) [\[39\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=provide%20the%20means%20for%20SCORM,the%20SCORM%20RTE%20Data%20Model) [\[40\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=The%20SCORM%20RTE%20Data%20Model%2C,have%20impacts%20on%20the%20SCORM) [\[41\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=A%20SCO%20is%20required%20to,the%20nature%20of%20the%20content) [\[60\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20Any%20LMS%20that%20supports,SCO%20in%20the%20same%20way) [\[61\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=1,the%20intended%20behavior%20of%20an) [\[62\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=authored%20learning%20experience%20such%20that,terms%20of%20an%20activity%20tree) [\[63\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=The%20SCORM%20SN%20Model%20defines,Some%20Rights%20Reserved) [\[64\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=activity%20tree%2C%20CAM,a%20conceptual%20structure%20of%20learning) [\[85\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=Attributes%3A%20%E2%80%A2%20randomizationTiming%20,the%20number%20of%20child%20activities) [\[86\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=activity%20,This%20attribute%20indicates%20when%20the) [\[87\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=o%20onEachNewAttempt%20%E2%80%A2%20selectCount%20,XML%20Data%20Type%3A%20xs%3Aboolean) [\[90\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%E2%80%A2%20tracked%20,activity%2Fattempt%20progress%20information%20for%20the) [\[91\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=attempt%20should%20be%20recorded%20,5) [\[92\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=for%20its%20parent%20activity%20,XML%20Data%20Type%3A%20xs%3Aboolean) [\[93\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=indicates%20that%20the%20attempt%20completion,Elements%3A%20%E2%80%A2%20None) [\[94\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=%28true%20or%20false%29%20,XML%20Data%20Type%3A%20xs%3Aboolean) [\[103\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=and%20an%20authored%20sequencing%20strategy,for%20delivery%20will%20have%20an) [\[104\]](file://file-JEeBdzT6dQgEDKj9FSkgRY#:~:text=learning%20activities%20managed%20by%20the,how%20identified%20content%20objects%20are) SCORM 2004 4th Edition Content Aggregation Model.txt

[\[13\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,Should%20be%20unique) [\[14\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,used%20in%20a%20meaningful%20manner) [\[19\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=elements.%20,section%20for%20a%20full%20description) [\[20\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=most%20manifests%20contain%20only%20one,ways%20the%20content%20in%20this) [\[21\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,should%20be%20passed%20to%20an) [\[22\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,not%20contain%20an%20identifierref%20attribute) [\[23\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,Similar%20to%20the%20parameters%20attribute) [\[24\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=metadata%20section%20for%20a%20full,0%3A1%5DThe%20minimum%20threshold%20of%20progress) [\[36\]](https://scorm.com/scorm-explained/technical-scorm/content-packaging/manifest-structure/#:~:text=,to) SCORM 2004 Manifest Structure

[\[38\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=2,sub%29manifests) [\[58\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Navigation%20controls%20are%20user%20interface,Some%20Rights%20Reserved) [\[59\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=SCORM%20requires%20that%20an%20LMS,that%20trigger%20Continue%2C%20Previous%2C%20and) [\[65\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=ignore%20the%20Continue%20navigation%20event,translate%20the%20navigation%20event%20into) [\[66\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=2,translate%20the%20navigation%20event%20into) [\[67\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Process,request%20to%20target%20this%20activity) [\[68\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=%E2%80%A2%20If%20satisfied%20Then%20skip%3A,allow%20a%20Choice%20sequencing%20request) [\[69\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=the%20activity%20is%20satisfied,allow%20a%20Choice%20sequencing%20request) [\[70\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=%E2%80%A2%20If%20satisfied%20Then%20skip%3A,Some%20Rights%20Reserved) [\[71\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=attempted,definition%20of%20the%20sequencing%20rule) [\[72\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Post%20Condition%20Actions%203%20Rule,Return%20a%20Retry%20sequencing%20request) [\[73\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=%E2%80%A2%20Retry%20%E2%80%93%20Return%20a,Vocabulary%20Ignore) [\[74\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=request%20and%20return%20a%20Start,Vocabulary%20Ignore) [\[75\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Table%203,Forward%20Traversal%20Rule%20Action%20when) [\[76\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=them,condition%20set%20results) [\[77\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=,condition%20set) [\[78\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=4,Evaluating%20Precondition%20Sequencing%20Rules) [\[79\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=the%20Max%20Attempt%20Limit%20limit,action) [\[80\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=4,based%20limit%20conditions) [\[81\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=SCORM%202004%204th%20EditionSequencing%20and,equal%20to%20False%2C%20then%20the) [\[82\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=%E2%80%A2%20If%20all%20completed%2C%20Then,Measure%20have%20no%20effect%20on) [\[83\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Figure%204,satisfied%20rule%20is%20evaluated%20first) [\[84\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=actions%20satisfied%20or%20not%20satisfied%2C,satisfied%20rule%20is%20evaluated%20first) [\[88\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=considered%20during%20any%20sequencing%20behavior,during%20rollup%20and%20the%20various) [\[89\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=starting%20the%20sequencing%20session,during%20rollup%20and%20the%20various) [\[95\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=For%20example%2C%20if%20the%20learner,translate%20the%20navigation%20event%20into) [\[96\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Start%20If%20the%20Current%20Activity,is%20True%2C%20issue%20an%20Exit) [\[97\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Continue%20If%20Activity%20is%20Active,Issue%20a%20Previous%20sequencing%20request) [\[98\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=indicate%20the%20desire%20to%20navigate,In%20addition) [\[99\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=Continue%2C%20Previous%2C%20and%20Choice%20navigation,events%20will%20result%20in%20a) [\[100\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=SCORM%20also%20provides%20the%20means,5%3A%20The%20SCORM%C2%AE%20Navigation%20Model) [\[101\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=evaluates%20to%20True,and%20return%20a%20Start%20sequencing) [\[102\]](file://file-VPQQHe5iM9Gb9dHJD3mBdL#:~:text=to%20identify%20that%20the%20content,potentially%20confusing%20user%20interface%20controls) SCORM 2004 4th EditionSequencing and Navigation.txt

[\[42\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=3,The%20API%20Instance) [\[43\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=The%20Termination%20After%20Termination%20error,The%20API%20Instance) [\[44\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=shall%20remain%20unchanged%20%28%E2%80%9CNot%20Initialized%E2%80%9D%29,%E2%80%9C%E2%80%9D%29%20%29%20more) [\[45\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=The%20Already%20Initialized%20error%20condition,shall%20be%20used%20when%20the) [\[46\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=Dot,IMS%20Simple%20Sequencing%20namespace%20attribute) [\[47\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=imsss%3AsatisfiedByMeasure%20associated%20with%20the%20,be%20initialized%20to%20any%20value) [\[48\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=%E2%80%A2%20If%20the%20IMS%20Simple,imsss%3AprimaryObjective) [\[49\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=to%20false%2C%20then%20the%20LMS,the%20error%20code%20to%200) [\[50\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=the%20SCO%20requests%20the%20value,Example) [\[51\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=Value%20Not%20Initialized%20and%20return,element%20based%20on%20the%20request) [\[52\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=LMS%20Behavior%20Requirements%3A%20%E2%80%A2%20The,imsss%3AprimaryObjective) [\[53\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=imsss%3AsatisfiedByMeasure%20associated%20with%20the%20,scaled_passing_score%20data%20model%20element) [\[54\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=%E2%80%A2%20The%20data%20model%20element,Data%20Model%20Element%20Implementation%20Requirements) [\[55\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=%E2%80%A2%20GetValue,%E2%80%9C%E2%80%9D) [\[56\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=SCO,when%20the%20SCO%20tries%20to) [\[57\]](file://file-WSYK5EkfNq5LKLi6iNX4cS#:~:text=The%20Termination%20Before%20Initialization%20error,The%20API%20Instance) SCORM 2004 4th Edition Run-Time Environment.txt